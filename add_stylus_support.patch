From 15df6c0d9e9d073c2eeb9ae1adb8a0bd19444901 Mon Sep 17 00:00:00 2001
From: Andrew Hughes <ashughes@gmail.com>
Date: Wed, 31 Aug 2011 13:35:41 -0700
Subject: [PATCH] Added active stylus support to the Android input framework as detailed
 in my thesis, available at
         http://digitalcommons.calpoly.edu/theses/536/

This commit comprises the entirety discussed in the thesis, however it
has not been cleaned up or commented well. I hope to have time to do
this in the future.

Change-Id: I7bd6f7f66c793c91530b0c2b75d5c91545b2b8ce
---
 Android.mk                                         |    2 +
 core/java/android/app/Activity.java                |    3 +
 core/java/android/app/ContextImpl.java             |   12 +
 core/java/android/app/IPointerManager.aidl         |   28 +
 core/java/android/app/Pointer.aidl                 |   19 +
 core/java/android/app/Pointer.java                 |  153 ++
 core/java/android/app/PointerManager.java          |  103 +
 core/java/android/content/Context.java             |   12 +
 core/java/android/view/IWindowManager.aidl         |    3 +
 core/java/android/view/InputDevice.java            |    9 +
 core/java/android/view/KeyEvent.java               |   52 +-
 core/java/android/view/MotionEvent.java            |   61 +-
 core/java/android/view/ViewGroup.java              |    6 +
 core/java/android/view/ViewRoot.java               |    4 +-
 core/jni/android_view_MotionEvent.cpp              |    8 +-
 core/res/res/drawable/pointer.png                  |  Bin 0 -> 287 bytes
 .../res/drawable/pointer_side_button_pressed.png   |  Bin 0 -> 889 bytes
 core/res/res/values/attrs.xml                      |    4 +-
 include/ui/EventHub.h                              |    3 +
 include/ui/Input.h                                 |    4 +
 include/ui/InputDispatcher.h                       |    7 +-
 include/ui/InputReader.h                           |  398 ++++
 include/ui/InputTransport.h                        |    2 +
 include/ui/KeycodeLabels.h                         |    2 +
 libs/ui/EventHub.cpp                               |    9 +-
 libs/ui/Input.cpp                                  |    2 +
 libs/ui/InputDispatcher.cpp                        |   68 +-
 libs/ui/InputReader.cpp                            | 2374 +++++++++++++++++++-
 libs/ui/InputTransport.cpp                         |    7 +-
 libs/ui/tests/InputDispatcher_test.cpp             |   20 +-
 libs/ui/tests/InputPublisherAndConsumer_test.cpp   |   18 +-
 libs/ui/tests/InputReader_test.cpp                 |    4 +-
 native/android/input.cpp                           |    4 +
 native/include/android/input.h                     |   47 +-
 native/include/android/keycodes.h                  |    2 +
 services/java/com/android/server/InputManager.java |    5 +-
 .../com/android/server/PointerManagerService.java  |  390 ++++
 services/java/com/android/server/SystemServer.java |   11 +
 .../com/android/server/WindowManagerService.java   |    8 +
 services/jni/com_android_server_InputManager.cpp   |    2 +-
 40 files changed, 3804 insertions(+), 62 deletions(-)
 create mode 100644 core/java/android/app/IPointerManager.aidl
 create mode 100644 core/java/android/app/Pointer.aidl
 create mode 100644 core/java/android/app/Pointer.java
 create mode 100644 core/java/android/app/PointerManager.java
 create mode 100644 core/res/res/drawable/pointer.png
 create mode 100644 core/res/res/drawable/pointer_side_button_pressed.png
 create mode 100644 services/java/com/android/server/PointerManagerService.java

diff --git a/Android.mk b/Android.mk
index e987eb7..96f47fa 100644
--- a/Android.mk
+++ b/Android.mk
@@ -83,6 +83,7 @@ LOCAL_SRC_FILES += \
 	core/java/android/app/IBackupAgent.aidl \
 	core/java/android/app/IInstrumentationWatcher.aidl \
 	core/java/android/app/INotificationManager.aidl \
+	core/java/android/app/IPointerManager.aidl \
 	core/java/android/app/ISearchManager.aidl \
 	core/java/android/app/ISearchManagerCallback.aidl \
 	core/java/android/app/IServiceConnection.aidl \
@@ -239,6 +240,7 @@ aidl_files := \
 	frameworks/base/core/java/android/accounts/IAccountAuthenticator.aidl \
 	frameworks/base/core/java/android/accounts/IAccountAuthenticatorResponse.aidl \
 	frameworks/base/core/java/android/app/Notification.aidl \
+	frameworks/base/core/java/android/app/Pointer.aidl \
 	frameworks/base/core/java/android/app/PendingIntent.aidl \
 	frameworks/base/core/java/android/bluetooth/BluetoothDevice.aidl \
 	frameworks/base/core/java/android/content/ComponentName.aidl \
diff --git a/core/java/android/app/Activity.java b/core/java/android/app/Activity.java
index f25c4c3..ee4d95b 100644
--- a/core/java/android/app/Activity.java
+++ b/core/java/android/app/Activity.java
@@ -2092,6 +2092,9 @@ public class Activity extends ContextThemeWrapper
     public boolean dispatchTouchEvent(MotionEvent ev) {
         if (ev.getAction() == MotionEvent.ACTION_DOWN) {
             onUserInteraction();
+        } else if (ev.getAction() == MotionEvent.ACTION_ENTER_PROXIMITY ||
+                   ev.getAction() == MotionEvent.ACTION_EXIT_PROXIMITY) {
+            //onStylusInRange(ev.getAction() == MotionEvent.ACTION_ENTER_PROXIMITY);
         }
         if (getWindow().superDispatchTouchEvent(ev)) {
             return true;
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 2dd5819..7b698cb 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -201,6 +201,7 @@ class ContextImpl extends Context {
     private DevicePolicyManager mDevicePolicyManager = null;
     private UiModeManager mUiModeManager = null;
     private DownloadManager mDownloadManager = null;
+    private PointerManager mPointerManager = null;
 
     private final Object mSync = new Object();
 
@@ -976,6 +977,8 @@ class ContextImpl extends Context {
             return getUiModeManager();
         } else if (DOWNLOAD_SERVICE.equals(name)) {
             return getDownloadManager();
+        } else if (POINTER_SERVICE.equals(name)) {
+            return getPointerManager();
         }
 
         return null;
@@ -1202,6 +1205,15 @@ class ContextImpl extends Context {
         }
         return mDownloadManager;
     }
+    
+    private PointerManager getPointerManager() {
+        synchronized (mSync) {
+            if (mPointerManager == null) {
+                mPointerManager = new PointerManager(this);
+            }
+        }
+        return mPointerManager;
+    }
 
     @Override
     public int checkPermission(String permission, int pid, int uid) {
diff --git a/core/java/android/app/IPointerManager.aidl b/core/java/android/app/IPointerManager.aidl
new file mode 100644
index 0000000..ce3d172
--- /dev/null
+++ b/core/java/android/app/IPointerManager.aidl
@@ -0,0 +1,28 @@
+/* //device/java/android/android/app/IPointerManager.aidl
+**
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License"); 
+** you may not use this file except in compliance with the License. 
+** You may obtain a copy of the License at 
+**
+**     http://www.apache.org/licenses/LICENSE-2.0 
+**
+** Unless required by applicable law or agreed to in writing, software 
+** distributed under the License is distributed on an "AS IS" BASIS, 
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+** See the License for the specific language governing permissions and 
+** limitations under the License.
+*/
+
+package android.app;
+
+import android.app.Pointer;
+
+/** {@hide} */
+interface IPointerManager
+{
+    void changePointer(String pkg, in Pointer pointer);
+    void resetPointer(String pkg);
+    void setVisible(String pkg, boolean visible);
+}
diff --git a/core/java/android/app/Pointer.aidl b/core/java/android/app/Pointer.aidl
new file mode 100644
index 0000000..d802b72
--- /dev/null
+++ b/core/java/android/app/Pointer.aidl
@@ -0,0 +1,19 @@
+/**
+ * Copyright (c) 2007, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.
+ */
+
+package android.app;
+
+parcelable Pointer;
diff --git a/core/java/android/app/Pointer.java b/core/java/android/app/Pointer.java
new file mode 100644
index 0000000..b15e330
--- /dev/null
+++ b/core/java/android/app/Pointer.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import android.content.Context;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+public class Pointer implements Parcelable
+{
+    /**
+     * The resource id of a drawable to use as the image for the pointer.
+     */
+    private int image;
+
+    /**
+     * The horizontal offset of the image to place the "point" at location 0.
+     */
+    private float offsetX;
+    
+    /**
+     * The vertical offset of the image to place the "point" at location 0.
+     */
+    private float offsetY;
+
+    /**
+     * Constructs a Pointer object with image resource and offset values.
+     *
+     * @param image      The resource id of the image to use as the pointer.
+     * @param offsetX    The horizontal offset of the image to place the "point" at location 0.
+     * @param offsetY    The vertical offset of the image to place the "point" at location 0.
+     */
+    public Pointer(int image, float offsetX, float offsetY) {
+        this.image = image;
+        this.offsetX = offsetX;
+        this.offsetY = offsetY;
+    }
+
+    /**
+     * Unflatten the notification from a parcel.
+     */
+    public Pointer(Parcel parcel) {
+        int version = parcel.readInt();
+
+        image = parcel.readInt();
+        offsetX = parcel.readFloat();
+        offsetY = parcel.readFloat();
+    }
+
+    public Pointer clone() {
+        return new Pointer(this.image, this.offsetX, this.offsetY);
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Flatten this notification from a parcel.
+     */
+    public void writeToParcel(Parcel parcel, int flags) {
+        // version code
+        parcel.writeInt(1);
+
+        parcel.writeInt(image);
+        parcel.writeFloat(offsetX);
+        parcel.writeFloat(offsetY);
+    }
+
+    /**
+     * Parcelable.Creator that instantiates Pointer objects
+     */
+    public static final Parcelable.Creator<Pointer> CREATOR
+            = new Parcelable.Creator<Pointer>() {
+
+        public Pointer createFromParcel(Parcel parcel) {
+            return new Pointer(parcel);
+        }
+
+        public Pointer[] newArray(int size) {
+            return new Pointer[size];
+        }
+    };
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("Pointer(image=0x");
+        sb.append(Integer.toHexString(this.image));
+        sb.append(",offsetX=");
+        sb.append(Float.toString(this.offsetX));
+        sb.append(",offsetY=");
+        sb.append(Float.toString(this.offsetY));
+        sb.append(")");
+
+        return sb.toString();
+    }
+
+    /**
+     * Set the image resource.
+     *
+     * @param image The resource id of the image to use as the pointer.
+     */
+    public void setImage(int image) {
+        this.image = image;
+    }
+
+    /**
+     * Set the pointer image offset values.
+     *
+     * @param offsetX    The horizontal offset of the image to place the "point" at location 0.
+     * @param offsetY    The vertical offset of the image to place the "point" at location 0.
+     */
+    public void setOffset(float offsetX, float offsetY) {
+        this.offsetX = offsetX;
+        this.offsetY = offsetY;
+    }
+
+    /**
+     * Get the resource id for the image.
+     */
+    public int getImage() {
+        return image;
+    }
+
+    /**
+     * Get the horizontal offset for the pointer image.
+     */
+    public float getOffsetX() {
+        return offsetX;
+    }
+
+    /**
+     * Get the vertical offset for the pointer image.
+     */
+    public float getOffsetY() {
+        return offsetY;
+    }
+}
diff --git a/core/java/android/app/PointerManager.java b/core/java/android/app/PointerManager.java
new file mode 100644
index 0000000..6717c26
--- /dev/null
+++ b/core/java/android/app/PointerManager.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.os.IBinder;
+import android.os.ServiceManager;
+import android.util.Log;
+
+/**
+ * Class to manage the look of the pointer.
+ *
+ * You do not instantiate this class directly; instead, retrieve it through
+ * {@link android.content.Context#getSystemService}.
+ *
+ * @see android.app.Pointer
+ * @see android.content.Context#getSystemService
+ */
+public class PointerManager
+{
+    private static String TAG = "PointerManager";
+    private static boolean DEBUG = true;
+
+    private static IPointerManager sService;
+
+    private Context mContext;
+
+    /** @hide */
+    static public IPointerManager getService() {
+        if (sService != null) {
+            return sService;
+        }
+        IBinder b = ServiceManager.getService("pointer");
+        sService = IPointerManager.Stub.asInterface(b);
+        return sService;
+    }
+
+    /*package*/ PointerManager(Context context)
+    {
+        mContext = context;
+    }
+
+    /**
+     * Change the current image used for the pointer.
+     *
+     * @param pointer A {@link Pointer} object providing an image and offset to
+     *                display a new pointer. Must not be null;
+     */
+    public void changePointer(Pointer pointer) {
+        if (pointer == null) {
+            return;
+        }
+
+        IPointerManager service = getService();
+        String pkg = mContext.getPackageName();
+        try {
+            service.changePointer(pkg, pointer);
+        } catch (RemoteException e) {
+        }
+    }
+    
+    /**
+     * Reset the pointer to its default state.
+     */
+    public void resetPointer() {
+        IPointerManager service = getService();
+        String pkg = mContext.getPackageName();
+        try {
+            service.resetPointer(pkg);
+        } catch (RemoteException e) {
+        }
+    }
+
+    /**
+     * Set whether the current pointer is visible or not.
+     *
+     * @param visible Set to true if visible, false if not.
+     */
+    public void setVisibe(boolean visible) {
+        IPointerManager service = getService();
+        String pkg = mContext.getPackageName();
+        try {
+            service.setVisible(pkg, visible);
+        } catch (RemoteException e) {
+        }
+    }
+}
diff --git a/core/java/android/content/Context.java b/core/java/android/content/Context.java
index 7563831..d62e984 100644
--- a/core/java/android/content/Context.java
+++ b/core/java/android/content/Context.java
@@ -1212,6 +1212,8 @@ public abstract class Context {
      * <dd> An {@link android.app.UiModeManager} for controlling UI modes.
      * <dt> {@link #DOWNLOAD_SERVICE} ("download")
      * <dd> A {@link android.app.DownloadManager} for requesting HTTP downloads
+     * <dt> {@link #POINTER_SERVICE} ("pointer")
+     * <dd> A {@link android.app.PointerManager} for modifying the displayed pointer.
      * </dl>
      *
      * <p>Note:  System services obtained via this API may be closely associated with
@@ -1261,6 +1263,8 @@ public abstract class Context {
      * @see android.app.UiModeManager
      * @see #DOWNLOAD_SERVICE
      * @see android.app.DownloadManager
+     * @see #POINTER_SERVICE
+     * @see android.app.PointerManager
      */
     public abstract Object getSystemService(String name);
 
@@ -1557,6 +1561,14 @@ public abstract class Context {
      */
     /** @hide */
     public static final String SIP_SERVICE = "sip";
+    
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.app.PointerManager} for modifying the displayed pointer.
+     *
+     * @see #getSystemService
+     */
+    public static final String POINTER_SERVICE = "pointer";
 
     /**
      * Determine whether the given permission is allowed for a particular
diff --git a/core/java/android/view/IWindowManager.aidl b/core/java/android/view/IWindowManager.aidl
index d4dd05c..fc64f22 100644
--- a/core/java/android/view/IWindowManager.aidl
+++ b/core/java/android/view/IWindowManager.aidl
@@ -156,4 +156,7 @@ interface IWindowManager
      * calls back when it changes.
      */
     int watchRotation(IRotationWatcher watcher);
+    
+    // (Hack) added to get top layer for drawing pointer
+    int getTopAnimLayer();
 }
diff --git a/core/java/android/view/InputDevice.java b/core/java/android/view/InputDevice.java
index dd04975..329dfbc 100755
--- a/core/java/android/view/InputDevice.java
+++ b/core/java/android/view/InputDevice.java
@@ -150,6 +150,14 @@ public final class InputDevice implements Parcelable {
     public static final int SOURCE_TOUCHPAD = 0x00100000 | SOURCE_CLASS_POSITION;
     
     /**
+     * The input source is an active pen digitizer that is associated with a
+     * display.
+     * 
+     * @see #SOURCE_CLASS_POINTER
+     */
+    public static final int SOURCE_ACTIVE_STYLUS = 0x00200000 | SOURCE_CLASS_POINTER;
+
+    /**
      * A special input source constant that is used when filtering input devices
      * to match devices that provide any type of input source.
      */
@@ -476,6 +484,7 @@ public final class InputDevice implements Parcelable {
         appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, "mouse");
         appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, "trackball");
         appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, "touchpad");
+        appendSourceDescriptionIfApplicable(description, SOURCE_ACTIVE_STYLUS, "active stylus");
         description.append("\n");
         
         appendRangeDescriptionIfApplicable(description, MOTION_RANGE_X, "x");
diff --git a/core/java/android/view/KeyEvent.java b/core/java/android/view/KeyEvent.java
index b58a65c..a10ccd8 100755
--- a/core/java/android/view/KeyEvent.java
+++ b/core/java/android/view/KeyEvent.java
@@ -331,6 +331,12 @@ public class KeyEvent extends InputEvent implements Parcelable {
     /** Key code constant: Mode Button key.
      * On a game controller, the button labeled Mode. */
     public static final int KEYCODE_BUTTON_MODE     = 110;
+    /** Key code constant: Primary Stylus Button key.
+     * On an active stylus, the primary side button. */
+    public static final int KEYCODE_BUTTON_STYLUS   = 111;
+    /** Key code constant: Secondary Stylus Button key.
+     * On an active stylus, the secondary side button. */
+    public static final int KEYCODE_BUTTON_STYLUS2  = 112;
 
     /**
      * @hide
@@ -407,7 +413,7 @@ public class KeyEvent extends InputEvent implements Parcelable {
     //  native/include/android/keycodes.h
     //  frameworks/base/include/ui/KeycodeLabels.h
     //  external/webkit/WebKit/android/plugins/ANPKeyCodes.h
-    //  tools/puppet_master/PuppetMaster/nav_keys.py
+    //  tools/puppet_master/PuppetMaster/nav_keys.py <-- couldn't find
     //  frameworks/base/core/res/res/values/attrs.xml
     //  commands/monkey/Monkey.java
     //  emulator?
@@ -418,7 +424,7 @@ public class KeyEvent extends InputEvent implements Parcelable {
     //  those new codes.  This is intended to maintain a consistent
     //  set of key code definitions across all Android devices.
    
-    private static final int LAST_KEYCODE           = KEYCODE_BUTTON_MODE;
+    private static final int LAST_KEYCODE           = KEYCODE_BUTTON_STYLUS2;
     
     /**
      * @deprecated There are now more than MAX_KEYCODE keycodes.
@@ -511,6 +517,24 @@ public class KeyEvent extends InputEvent implements Parcelable {
     public static final int META_SYM_ON = 0x4;
 
     /**
+     * <p>This mask is used to check whether the primary stylus button is pressed.</p>
+     *
+     * @see #isStylusButtonPressed()
+     * @see #getMetaState()
+     * @see #KEYCODE_BUTTON_STYLUS
+     */
+    public static final int META_BTN_STYLUS_ON = 0x100;
+    
+    /**
+     * <p>This mask is used to check whether the secondary stylus button is pressed.</p>
+     *
+     * @see #isSecStylusButtonPressed()
+     * @see #getMetaState()
+     * @see #KEYCODE_BUTTON_STYLUS2
+     */
+    public static final int META_BTN_STYLUS2_ON = 0x200;
+
+    /**
      * This mask is set if the device woke because of this key event.
      */
     public static final int FLAG_WOKE_HERE = 0x1;
@@ -1079,6 +1103,30 @@ public class KeyEvent extends InputEvent implements Parcelable {
     }
 
     /**
+     * <p>Returns the pressed state of the primary stylus button meta key.</p>
+     *
+     * @return true if the primary stylus button is pressed, false otherwise
+     *
+     * @see #KEYCODE_BUTTON_STYLUS
+     * @see #META_BTN_STYLUS_ON
+     */
+    public final boolean isStylusButtonPressed() {
+        return (mMetaState & META_BTN_STYLUS_ON) != 0;
+    }
+    
+    /**
+     * <p>Returns the pressed state of the secondary stylus button meta key.</p>
+     *
+     * @return true if the secondary stylus button is pressed, false otherwise
+     *
+     * @see #KEYCODE_BUTTON_STYLUS2
+     * @see #META_BTN_STYLUS2_ON
+     */
+    public final boolean isSecStylusButtonPressed() {
+        return (mMetaState & META_BTN_STYLUS2_ON) != 0;
+    }
+
+    /**
      * Retrieve the action of this key event.  May be either
      * {@link #ACTION_DOWN}, {@link #ACTION_UP}, or {@link #ACTION_MULTIPLE}.
      * 
diff --git a/core/java/android/view/MotionEvent.java b/core/java/android/view/MotionEvent.java
index c2fec96..fb87aee 100644
--- a/core/java/android/view/MotionEvent.java
+++ b/core/java/android/view/MotionEvent.java
@@ -128,7 +128,7 @@ public final class MotionEvent extends InputEvent implements Parcelable {
      * an up event, but not perform any action that you normally would.
      */
     public static final int ACTION_CANCEL           = 3;
-    
+
     /**
      * Constant for {@link #getAction}: A movement has happened outside of the
      * normal bounds of the UI element.  This does not provide a full gesture,
@@ -149,6 +149,26 @@ public final class MotionEvent extends InputEvent implements Parcelable {
     public static final int ACTION_POINTER_UP       = 6;
     
     /**
+     * Constant for {@link #getAction}: The {@link InputDevice} is hovering
+     * above but not touching the surface. The motion contains the most recent
+     * point, as well as any intermediate points since the last up or hover
+     * event (similar to an {@link #ACTION_MOVE}). This will only occur between
+     * an {@link #ACTION_UP} and {@link #ACTION_DOWN} for {@link InputDevice}s
+     * that support hover.
+     */
+    public static final int ACTION_HOVER            = 7;
+
+    /**
+     * TODO: add comment
+     */
+    public static final int ACTION_ENTER_PROXIMITY  = 8;
+
+    /**
+     * TODO: add comment
+     */
+    public static final int ACTION_EXIT_PROXIMITY   = 9;
+    
+    /**
      * Bits in the action code that represent a pointer index, used with
      * {@link #ACTION_POINTER_DOWN} and {@link #ACTION_POINTER_UP}.  Shifting
      * down by {@link #ACTION_POINTER_INDEX_SHIFT} provides the actual pointer
@@ -252,6 +272,22 @@ public final class MotionEvent extends InputEvent implements Parcelable {
      */
     public static final int EDGE_RIGHT = 0x00000008;
 
+    /**
+     * The tool type used is unknown. This is the default tool type for an
+     * input device that does not support tool type.
+     */
+    public static final int TOOL_TYPE_NONE = 0;
+
+    /**
+     * The event is being performed by the pen tool.
+     */
+    public static final int TOOL_TYPE_PEN = 1;
+
+    /**
+     * The event is being performed by the "rubber" or eraser tool.
+     */
+    public static final int TOOL_TYPE_RUBBER = 2;
+
     /*
      * Offset for the sample's X coordinate.
      */
@@ -320,6 +356,7 @@ public final class MotionEvent extends InputEvent implements Parcelable {
 
     private long mDownTimeNano;
     private int mAction;
+    private int mToolType;
     private float mXOffset;
     private float mYOffset;
     private float mXPrecision;
@@ -429,6 +466,7 @@ public final class MotionEvent extends InputEvent implements Parcelable {
         ev.mEdgeFlags = edgeFlags;
         ev.mDownTimeNano = downTime * MS_PER_NS;
         ev.mAction = action;
+        ev.mToolType = TOOL_TYPE_NONE;
         ev.mFlags = flags;
         ev.mMetaState = metaState;
         ev.mXOffset = 0;
@@ -491,6 +529,7 @@ public final class MotionEvent extends InputEvent implements Parcelable {
         ev.mEdgeFlags = edgeFlags;
         ev.mDownTimeNano = downTime * MS_PER_NS;
         ev.mAction = action;
+        ev.mToolType = TOOL_TYPE_NONE;
         ev.mFlags = 0;
         ev.mMetaState = metaState;
         ev.mXOffset = 0;
@@ -588,6 +627,7 @@ public final class MotionEvent extends InputEvent implements Parcelable {
         ev.mEdgeFlags = o.mEdgeFlags;
         ev.mDownTimeNano = o.mDownTimeNano;
         ev.mAction = o.mAction;
+        ev.mToolType = o.mToolType;
         ev.mFlags = o.mFlags;
         ev.mMetaState = o.mMetaState;
         ev.mXOffset = o.mXOffset;
@@ -620,6 +660,7 @@ public final class MotionEvent extends InputEvent implements Parcelable {
         ev.mEdgeFlags = o.mEdgeFlags;
         ev.mDownTimeNano = o.mDownTimeNano;
         ev.mAction = o.mAction;
+        ev.mToolType = o.mToolType;
         o.mFlags = o.mFlags;
         ev.mMetaState = o.mMetaState;
         ev.mXOffset = o.mXOffset;
@@ -732,6 +773,13 @@ public final class MotionEvent extends InputEvent implements Parcelable {
     }
 
     /**
+     * Return the kind of tool type being used.
+     */
+    public final int getToolType() {
+        return mToolType;
+    }
+
+    /**
      * Gets the motion event flags.
      *
      * @see #FLAG_WINDOW_IS_OBSCURED
@@ -1390,6 +1438,13 @@ public final class MotionEvent extends InputEvent implements Parcelable {
     public final void setAction(int action) {
         mAction = action;
     }
+    
+    /**
+     * Sets this event's tool type.
+     */
+    public final void setToolType(int toolType) {
+        mToolType = toolType;
+    }
 
     /**
      * Adjust this event's location.
@@ -1534,7 +1589,7 @@ public final class MotionEvent extends InputEvent implements Parcelable {
     @Override
     public String toString() {
         return "MotionEvent{" + Integer.toHexString(System.identityHashCode(this))
-            + " action=" + mAction + " x=" + getX()
+            + " action=" + mAction + " tooltype=" + mToolType + " x=" + getX()
             + " y=" + getY() + " pressure=" + getPressure() + " size=" + getSize() + "}";
     }
 
@@ -1564,6 +1619,7 @@ public final class MotionEvent extends InputEvent implements Parcelable {
         
         ev.mDownTimeNano = in.readLong();
         ev.mAction = in.readInt();
+        ev.mToolType = in.readInt();
         ev.mXOffset = in.readFloat();
         ev.mYOffset = in.readFloat();
         ev.mXPrecision = in.readFloat();
@@ -1606,6 +1662,7 @@ public final class MotionEvent extends InputEvent implements Parcelable {
         
         out.writeLong(mDownTimeNano);
         out.writeInt(mAction);
+        out.writeInt(mToolType);
         out.writeFloat(mXOffset);
         out.writeFloat(mYOffset);
         out.writeFloat(mXPrecision);
diff --git a/core/java/android/view/ViewGroup.java b/core/java/android/view/ViewGroup.java
index b9864ba..9dd6da5 100644
--- a/core/java/android/view/ViewGroup.java
+++ b/core/java/android/view/ViewGroup.java
@@ -822,6 +822,8 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
      */
     @Override
     public boolean dispatchTouchEvent(MotionEvent ev) {
+        Log.d("ViewGroup", "Begin: " + ev.toString());
+
         if (!onFilterTouchEventForSecurity(ev)) {
             return false;
         }
@@ -869,6 +871,7 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
                             if (child.dispatchTouchEvent(ev))  {
                                 // Event handled, we have a target now.
                                 mMotionTarget = child;
+                                Log.d("ViewGroup", "1: " + ev.toString());
                                 return true;
                             }
                             // The event didn't get handled, try the next view.
@@ -900,6 +903,7 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
                 ev.setAction(MotionEvent.ACTION_CANCEL);
                 mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;
             }
+            Log.d("ViewGroup", "2: " + ev.toString());
             return super.dispatchTouchEvent(ev);
         }
 
@@ -920,6 +924,7 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
             // Don't dispatch this event to our own view, because we already
             // saw it when intercepting; we just want to give the following
             // event to the normal onTouchEvent().
+            Log.d("ViewGroup", "3: " + ev.toString());
             return true;
         }
 
@@ -939,6 +944,7 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
             mMotionTarget = null;
         }
 
+        Log.d("ViewGroup", "End: " + ev.toString());
         return target.dispatchTouchEvent(ev);
     }
 
diff --git a/core/java/android/view/ViewRoot.java b/core/java/android/view/ViewRoot.java
index 2361d1f..4c85e4c 100644
--- a/core/java/android/view/ViewRoot.java
+++ b/core/java/android/view/ViewRoot.java
@@ -86,7 +86,7 @@ public final class ViewRoot extends Handler implements ViewParent,
     private static final boolean DEBUG_CONFIGURATION = false || LOCAL_LOGV;
     private static final boolean WATCH_POINTER = false;
 
-    private static final boolean MEASURE_LATENCY = false;
+    private static final boolean MEASURE_LATENCY = true;
     private static LatencyTimer lt;
 
     /**
@@ -2170,6 +2170,8 @@ public final class ViewRoot extends Handler implements ViewParent,
     }
 
     private void deliverPointerEvent(MotionEvent event) {
+        Log.d(TAG, "Begin: " + event.toString());
+
         if (mTranslator != null) {
             mTranslator.translateEventInScreenToAppWindow(event);
         }
diff --git a/core/jni/android_view_MotionEvent.cpp b/core/jni/android_view_MotionEvent.cpp
index 93fd54f..0f953fd 100644
--- a/core/jni/android_view_MotionEvent.cpp
+++ b/core/jni/android_view_MotionEvent.cpp
@@ -40,6 +40,7 @@ static struct {
     jfieldID mSource;
     jfieldID mDownTimeNano;
     jfieldID mAction;
+    jfieldID mToolType;
     jfieldID mXOffset;
     jfieldID mYOffset;
     jfieldID mXPrecision;
@@ -80,6 +81,8 @@ jobject android_view_MotionEvent_fromNative(JNIEnv* env, const MotionEvent* even
             event->getDownTime());
     env->SetIntField(eventObj, gMotionEventClassInfo.mAction,
             event->getAction());
+    env->SetIntField(eventObj, gMotionEventClassInfo.mToolType,
+            event->getToolType());
     env->SetFloatField(eventObj, gMotionEventClassInfo.mXOffset,
             event->getXOffset());
     env->SetFloatField(eventObj, gMotionEventClassInfo.mYOffset,
@@ -159,6 +162,7 @@ void android_view_MotionEvent_toNative(JNIEnv* env, jobject eventObj,
     jint source = env->GetIntField(eventObj, gMotionEventClassInfo.mSource);
     jlong downTimeNano = env->GetLongField(eventObj, gMotionEventClassInfo.mDownTimeNano);
     jint action = env->GetIntField(eventObj, gMotionEventClassInfo.mAction);
+    jint toolType = env->GetIntField(eventObj, gMotionEventClassInfo.mToolType);
     jfloat xOffset = env->GetFloatField(eventObj, gMotionEventClassInfo.mXOffset);
     jfloat yOffset = env->GetFloatField(eventObj, gMotionEventClassInfo.mYOffset);
     jfloat xPrecision = env->GetFloatField(eventObj, gMotionEventClassInfo.mXPrecision);
@@ -200,7 +204,7 @@ void android_view_MotionEvent_toNative(JNIEnv* env, jobject eventObj,
         samplePointerCoords[j].orientation = *(srcDataSamples++);
     }
 
-    event->initialize(deviceId, source, action, flags, edgeFlags, metaState,
+    event->initialize(deviceId, source, action, toolType, flags, edgeFlags, metaState,
             xOffset, yOffset, xPrecision, yPrecision, downTimeNano, sampleEventTime,
             numPointers, pointerIdentifiers, samplePointerCoords);
 
@@ -273,6 +277,8 @@ int register_android_view_MotionEvent(JNIEnv* env) {
             "mDownTimeNano", "J");
     GET_FIELD_ID(gMotionEventClassInfo.mAction, gMotionEventClassInfo.clazz,
             "mAction", "I");
+    GET_FIELD_ID(gMotionEventClassInfo.mToolType, gMotionEventClassInfo.clazz,
+            "mToolType", "I");
     GET_FIELD_ID(gMotionEventClassInfo.mXOffset, gMotionEventClassInfo.clazz,
             "mXOffset", "F");
     GET_FIELD_ID(gMotionEventClassInfo.mYOffset, gMotionEventClassInfo.clazz,
diff --git a/core/res/res/drawable/pointer.png b/core/res/res/drawable/pointer.png
new file mode 100644
index 0000000000000000000000000000000000000000..505590e67248585dea6fba2a591f1a74b131e978
GIT binary patch
literal 287
zcmeAS@N?(olHy`uVBq!ia0vp^LLkh+1|-AI^@Rf|#^NA%Cx&(BWL^R}Y)RhkE)4%c
zaKYZ?lYt_f1s;*b3=G`DAk4@xYmNj^kiEpy*OmP?t27(CoR`?SEkGg364!_l=ltB<
z)VvY~=c3falGGH1^30M91$R&1fbd2>aiF3qPZ!4!i_^&o3Jf);xBvUDd;iz`307)s
zT8v^&TyZr?YNr%d?d%Yo-jeyO?>`R^m}yOTU|Gbz=*yQ9ez#w{IPR+cJvy%kB-6V0
z_W#Gll3!z3yp=cHa4hGvawwn4a{qp!yj!!LtRTy>nb!Xf$Cz6b+3U=`aMqRK#Bp0A
Uah}Offv#ZiboFyt=akR{0BvJky8r+H

literal 0
HcmV?d00001

diff --git a/core/res/res/drawable/pointer_side_button_pressed.png b/core/res/res/drawable/pointer_side_button_pressed.png
new file mode 100644
index 0000000000000000000000000000000000000000..df7fdcaa8336652a5cbcf2943207d4d747d3c009
GIT binary patch
literal 889
zcmV-<1BU#GP)<h;3K|Lk000e1NJLTq0015U0015c1^@s6J20-I00001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2ipZ7
z7X=st#a9ym000?uMObu0Z*6U5Zgc=ca%Ew3Wn>_CX>@2HM@dakSAh-}0008iNkl<Z
zNXNyOPe@cz6vlsV977~#Q4(U%rodeUq4Y<pL5hakWkA<0qJ>HjMByb$A+X{}(jqAP
z<DzI2kztq1xG2VjQY5qt1UIdeawQQGm@Pbacuh0T8&f-*H|M_l&Ntt8?>YC}fS9I@
z+X=J+Ex<`&Kai5w7I+R!0&_N0E0y8}6~F@E6fh`2aqI`s58Sh%`dMyLVhzwez-M4w
zK&OH0KpJSWp$dR)K$DDJmpS#o9pIZb?s!#<wQ=phTXA#1pbgbT%q2Mi^a2?fdIEIW
zQ2kmHSR2;^+!wdohUy{fFl}5HFf8t<4OM4ZskL!81#}TeuNM?RzD-N44sG1El8i;7
zytwH~(rV*Y1R#hZy^q^zLp54ptc^=bN_crE*dUWw-QvE|#_ftqt%2=8F0Q=ui#5zI
z)>I>VPTYQggf=b#Jd(jdHqU(Q3);B)KpS@mcn?h5P_<V2x}|4)1)y!;YH^yJU0veo
z2d9G=JN=_nz5@x78DNafH;-{JDRmcMsv4$uFJ}UPOGCNU0eN46xyNWvNXY}3*#gEM
z<4h9REzUxzJoP)bn5nmN%o|h7l*n_BkxKBNED3y<9Bu&SBDweHS_u=+te9!c-Q5ta
z)$inY^A-^G7$1_rQy>c*1<IDn0+S-<)#R~Y01PD}VA(BT>@o6z?BH2oZ=6%9IIm+e
zjh<3-HdIZ1S6`85?<TVKv2RCDr#HY?AS0baMQcng7jiXbH<AICfX4-3>4%QUykU`L
zLrh}%7U--E)zV)*mp1OaG-r!I_Fo$U0UeY6d%%XOuVl|<Lp1`tl!^Jcvaca;USi#f
zf|lzt17HL=w?XY~pAFSO?3;u(?ilbI*x_r4$TkJc*ig-B<7%Z0HcN5H%0UnC1?aG$
z`m~-aOf7H&xLSqE3&2I-MR5}!8#wX@>ZC_L47AC!F1kH{XQIY@oJ-qpW#AVG)Y)lk
P00000NkvXXu0mjfq)&R7

literal 0
HcmV?d00001

diff --git a/core/res/res/values/attrs.xml b/core/res/res/values/attrs.xml
index 715ca3c..23f1f8b 100755
--- a/core/res/res/values/attrs.xml
+++ b/core/res/res/values/attrs.xml
@@ -936,7 +936,7 @@
         <enum name="KEYCODE_MEDIA_REWIND" value="89" />
         <enum name="KEYCODE_MEDIA_FAST_FORWARD" value="90" />
         <enum name="KEYCODE_MUTE" value="91" />
-        enum name="KEYCODE_PAGE_UP" value="92" />
+        <enum name="KEYCODE_PAGE_UP" value="92" />
         <enum name="KEYCODE_PAGE_DOWN" value="93" />
         <enum name="KEYCODE_PICTSYMBOLS" value="94" />
         <enum name="KEYCODE_SWITCH_CHARSET" value="95" />
@@ -955,6 +955,8 @@
         <enum name="KEYCODE_BUTTON_START" value="108" />
         <enum name="KEYCODE_BUTTON_SELECT" value="109" />
         <enum name="KEYCODE_BUTTON_MODE" value="110" />
+        <enum name="KEYCODE_BUTTON_STYLUS" value="111" />
+        <enum name="KEYCODE_BUTTON_STYLUS2" value="112" />
         <enum name="KEYCODE_FUNC_1" value="92" />
         <enum name="KEYCODE_FUNC_2" value="93" />
         <enum name="KEYCODE_FUNC_3" value="94" />
diff --git a/include/ui/EventHub.h b/include/ui/EventHub.h
index d78e35f..e35427e 100644
--- a/include/ui/EventHub.h
+++ b/include/ui/EventHub.h
@@ -119,6 +119,9 @@ enum {
 
     /* The input device has switches. */
     INPUT_DEVICE_CLASS_SWITCH        = 0x00000080,
+
+    /* The input device is an active pen digitizer */
+    INPUT_DEVICE_CLASS_ACTIVE_DIGITIZER = 0x00000100,
 };
 
 /*
diff --git a/include/ui/Input.h b/include/ui/Input.h
index 8c6018b..efe687f 100644
--- a/include/ui/Input.h
+++ b/include/ui/Input.h
@@ -251,6 +251,8 @@ public:
 
     inline int32_t getAction() const { return mAction; }
 
+    inline int32_t getToolType() const { return mToolType; }
+
     inline int32_t getFlags() const { return mFlags; }
 
     inline int32_t getEdgeFlags() const { return mEdgeFlags; }
@@ -371,6 +373,7 @@ public:
             int32_t deviceId,
             int32_t source,
             int32_t action,
+            int32_t toolType,
             int32_t flags,
             int32_t edgeFlags,
             int32_t metaState,
@@ -399,6 +402,7 @@ public:
 
 private:
     int32_t mAction;
+    int32_t mToolType;
     int32_t mFlags;
     int32_t mEdgeFlags;
     int32_t mMetaState;
diff --git a/include/ui/InputDispatcher.h b/include/ui/InputDispatcher.h
index b9428af..a70b848 100644
--- a/include/ui/InputDispatcher.h
+++ b/include/ui/InputDispatcher.h
@@ -356,7 +356,7 @@ public:
             uint32_t policyFlags, int32_t action, int32_t flags, int32_t keyCode,
             int32_t scanCode, int32_t metaState, nsecs_t downTime) = 0;
     virtual void notifyMotion(nsecs_t eventTime, int32_t deviceId, int32_t source,
-            uint32_t policyFlags, int32_t action, int32_t flags,
+            uint32_t policyFlags, int32_t action, int32_t toolType, int32_t flags,
             int32_t metaState, int32_t edgeFlags,
             uint32_t pointerCount, const int32_t* pointerIds, const PointerCoords* pointerCoords,
             float xPrecision, float yPrecision, nsecs_t downTime) = 0;
@@ -433,7 +433,7 @@ public:
             uint32_t policyFlags, int32_t action, int32_t flags, int32_t keyCode,
             int32_t scanCode, int32_t metaState, nsecs_t downTime);
     virtual void notifyMotion(nsecs_t eventTime, int32_t deviceId, int32_t source,
-            uint32_t policyFlags, int32_t action, int32_t flags,
+            uint32_t policyFlags, int32_t action, int32_t toolType, int32_t flags,
             int32_t metaState, int32_t edgeFlags,
             uint32_t pointerCount, const int32_t* pointerIds, const PointerCoords* pointerCoords,
             float xPrecision, float yPrecision, nsecs_t downTime);
@@ -521,6 +521,7 @@ private:
         int32_t deviceId;
         int32_t source;
         int32_t action;
+        int32_t toolType;
         int32_t flags;
         int32_t metaState;
         int32_t edgeFlags;
@@ -663,7 +664,7 @@ private:
                 int32_t flags, int32_t keyCode, int32_t scanCode, int32_t metaState,
                 int32_t repeatCount, nsecs_t downTime);
         MotionEntry* obtainMotionEntry(nsecs_t eventTime,
-                int32_t deviceId, int32_t source, uint32_t policyFlags, int32_t action,
+                int32_t deviceId, int32_t source, uint32_t policyFlags, int32_t action, int32_t toolType,
                 int32_t flags, int32_t metaState, int32_t edgeFlags,
                 float xPrecision, float yPrecision,
                 nsecs_t downTime, uint32_t pointerCount,
diff --git a/include/ui/InputReader.h b/include/ui/InputReader.h
index 49351b0..bb1749a 100644
--- a/include/ui/InputReader.h
+++ b/include/ui/InputReader.h
@@ -922,6 +922,404 @@ private:
     void sync(nsecs_t when);
 };
 
+class ActiveStylusInputMapper : public InputMapper {
+public:
+    ActiveStylusInputMapper(InputDevice* device, int32_t associatedDisplayId);
+    virtual ~ActiveStylusInputMapper();
+
+    virtual uint32_t getSources();
+    virtual void populateDeviceInfo(InputDeviceInfo* deviceInfo);
+    virtual void dump(String8& dump);
+    virtual void configure();
+    virtual void reset();
+
+    virtual int32_t getKeyCodeState(uint32_t sourceMask, int32_t keyCode);
+    virtual int32_t getScanCodeState(uint32_t sourceMask, int32_t scanCode);
+    virtual bool markSupportedKeyCodes(uint32_t sourceMask, size_t numCodes,
+            const int32_t* keyCodes, uint8_t* outFlags);
+
+    virtual int32_t getMetaState();
+protected:
+    Mutex mLock;
+
+    struct VirtualKey {
+        int32_t keyCode;
+        int32_t scanCode;
+        uint32_t flags;
+
+        // computed hit box, specified in touch screen coords based on known display size
+        int32_t hitLeft;
+        int32_t hitTop;
+        int32_t hitRight;
+        int32_t hitBottom;
+
+        inline bool isHit(int32_t x, int32_t y) const {
+            return x >= hitLeft && x <= hitRight && y >= hitTop && y <= hitBottom;
+        }
+    };
+
+    // Raw data for a single pointer.
+    struct PointerData {
+        uint32_t id;
+        int32_t x;
+        int32_t y;
+        int32_t pressure;
+        int32_t touchMajor;
+        int32_t touchMinor;
+        int32_t toolMajor;
+        int32_t toolMinor;
+        int32_t orientation;
+        bool buttonStylus;
+        bool buttonStylus2;
+        uint32_t toolType;
+
+        inline bool operator== (const PointerData& other) const {
+            return id == other.id
+                    && x == other.x
+                    && y == other.y
+                    && pressure == other.pressure
+                    && touchMajor == other.touchMajor
+                    && touchMinor == other.touchMinor
+                    && toolMajor == other.toolMajor
+                    && toolMinor == other.toolMinor
+                    && orientation == other.orientation
+                    && buttonStylus == other.buttonStylus
+                    && buttonStylus2 == other.buttonStylus2
+                    && toolType == other.toolType;
+        }
+        inline bool operator!= (const PointerData& other) const {
+            return !(*this == other);
+        }
+    };
+
+    // Raw data for a collection of pointers including a pointer id mapping table.
+    struct TouchData {
+        uint32_t pointerCount;
+        PointerData pointers[MAX_POINTERS];
+        BitSet32 idBits;
+        uint32_t idToIndex[MAX_POINTER_ID + 1];
+
+        void copyFrom(const TouchData& other) {
+            pointerCount = other.pointerCount;
+            idBits = other.idBits;
+
+            for (uint32_t i = 0; i < pointerCount; i++) {
+                pointers[i] = other.pointers[i];
+
+                int id = pointers[i].id;
+                idToIndex[id] = other.idToIndex[id];
+            }
+        }
+
+        inline void clear() {
+            pointerCount = 0;
+            idBits.clear();
+        }
+    };
+
+    int32_t mAssociatedDisplayId;
+
+    // Immutable configuration parameters.
+    /*struct Parameters {
+        bool useBadTouchFilter;
+        bool useJumpyTouchFilter;
+        bool useAveragingTouchFilter;
+    } mParameters;*/
+
+    // Immutable calibration parameters in parsed form.
+    struct Calibration {
+        // Touch Size
+        enum TouchSizeCalibration {
+            TOUCH_SIZE_CALIBRATION_DEFAULT,
+            TOUCH_SIZE_CALIBRATION_NONE,
+            TOUCH_SIZE_CALIBRATION_GEOMETRIC,
+            TOUCH_SIZE_CALIBRATION_PRESSURE,
+        };
+
+        TouchSizeCalibration touchSizeCalibration;
+
+        // Tool Size
+        enum ToolSizeCalibration {
+            TOOL_SIZE_CALIBRATION_DEFAULT,
+            TOOL_SIZE_CALIBRATION_NONE,
+            TOOL_SIZE_CALIBRATION_GEOMETRIC,
+            TOOL_SIZE_CALIBRATION_LINEAR,
+            TOOL_SIZE_CALIBRATION_AREA,
+        };
+
+        ToolSizeCalibration toolSizeCalibration;
+        bool haveToolSizeLinearScale;
+        float toolSizeLinearScale;
+        bool haveToolSizeLinearBias;
+        float toolSizeLinearBias;
+        bool haveToolSizeAreaScale;
+        float toolSizeAreaScale;
+        bool haveToolSizeAreaBias;
+        float toolSizeAreaBias;
+        bool haveToolSizeIsSummed;
+        int32_t toolSizeIsSummed;
+
+        // Pressure
+        enum PressureCalibration {
+            PRESSURE_CALIBRATION_DEFAULT,
+            PRESSURE_CALIBRATION_NONE,
+            PRESSURE_CALIBRATION_PHYSICAL,
+            PRESSURE_CALIBRATION_AMPLITUDE,
+        };
+        enum PressureSource {
+            PRESSURE_SOURCE_DEFAULT,
+            PRESSURE_SOURCE_PRESSURE,
+            PRESSURE_SOURCE_TOUCH,
+        };
+
+        PressureCalibration pressureCalibration;
+        PressureSource pressureSource;
+        bool havePressureScale;
+        float pressureScale;
+
+        // Size
+        enum SizeCalibration {
+            SIZE_CALIBRATION_DEFAULT,
+            SIZE_CALIBRATION_NONE,
+            SIZE_CALIBRATION_NORMALIZED,
+        };
+
+        SizeCalibration sizeCalibration;
+
+        // Orientation
+        enum OrientationCalibration {
+            ORIENTATION_CALIBRATION_DEFAULT,
+            ORIENTATION_CALIBRATION_NONE,
+            ORIENTATION_CALIBRATION_INTERPOLATED,
+        };
+
+        OrientationCalibration orientationCalibration;
+    } mCalibration;
+
+    // Raw axis information from the driver.
+    struct RawAxes {
+        RawAbsoluteAxisInfo x;
+        RawAbsoluteAxisInfo y;
+        RawAbsoluteAxisInfo pressure;
+        RawAbsoluteAxisInfo touchMajor;
+        RawAbsoluteAxisInfo touchMinor;
+        RawAbsoluteAxisInfo toolMajor;
+        RawAbsoluteAxisInfo toolMinor;
+        RawAbsoluteAxisInfo orientation;
+    } mRawAxes;
+
+    // Current and previous touch sample data.
+    TouchData mCurrentTouch;
+    TouchData mLastTouch;
+
+    // The time the primary pointer last went down.
+    nsecs_t mDownTime;
+
+    struct LockedState {
+        Vector<VirtualKey> virtualKeys;
+
+        // The surface orientation and width and height set by configureSurfaceLocked().
+        int32_t surfaceOrientation;
+        int32_t surfaceWidth, surfaceHeight;
+
+        // Translation and scaling factors, orientation-independent.
+        int32_t xOrigin;
+        float xScale;
+        float xPrecision;
+
+        int32_t yOrigin;
+        float yScale;
+        float yPrecision;
+
+        float geometricScale;
+
+        float toolSizeLinearScale;
+        float toolSizeLinearBias;
+        float toolSizeAreaScale;
+        float toolSizeAreaBias;
+
+        float pressureScale;
+
+        float sizeScale;
+
+        float orientationScale;
+
+        // Oriented motion ranges for input device info.
+        struct OrientedRanges {
+            InputDeviceInfo::MotionRange x;
+            InputDeviceInfo::MotionRange y;
+
+            bool havePressure;
+            InputDeviceInfo::MotionRange pressure;
+
+            bool haveSize;
+            InputDeviceInfo::MotionRange size;
+
+            bool haveTouchSize;
+            InputDeviceInfo::MotionRange touchMajor;
+            InputDeviceInfo::MotionRange touchMinor;
+
+            bool haveToolSize;
+            InputDeviceInfo::MotionRange toolMajor;
+            InputDeviceInfo::MotionRange toolMinor;
+
+            bool haveOrientation;
+            InputDeviceInfo::MotionRange orientation;
+        } orientedRanges;
+
+        // Oriented dimensions and precision.
+        float orientedSurfaceWidth, orientedSurfaceHeight;
+        float orientedXPrecision, orientedYPrecision;
+
+        struct CurrentVirtualKeyState {
+            bool down;
+            nsecs_t downTime;
+            int32_t keyCode;
+            int32_t scanCode;
+        } currentVirtualKey;
+
+        int32_t metaState;
+    } mLocked;
+
+    //virtual void configureParameters();
+    //virtual void dumpParameters(String8& dump);
+    virtual void configureRawAxes();
+    virtual void dumpRawAxes(String8& dump);
+    virtual bool configureSurfaceLocked();
+    virtual void dumpSurfaceLocked(String8& dump);
+    virtual void configureVirtualKeysLocked();
+    virtual void dumpVirtualKeysLocked(String8& dump);
+    virtual void parseCalibration();
+    virtual void resolveCalibration();
+    virtual void dumpCalibration(String8& dump);
+
+    enum TouchResult {
+        // Dispatch the touch normally.
+        DISPATCH_TOUCH,
+        // Do not dispatch the touch, but keep tracking the current stroke.
+        SKIP_TOUCH,
+        // Do not dispatch the touch, and drop all information associated with the current stoke
+        // so the next movement will appear as a new down.
+        DROP_STROKE
+    };
+
+    void syncTouch(nsecs_t when, bool havePointerIds);
+
+private:
+    /* Maximum number of historical samples to average. */
+    //static const uint32_t AVERAGING_HISTORY_SIZE = 5;
+
+    /* Slop distance for jumpy pointer detection.
+     * The vertical range of the screen divided by this is our epsilon value. */
+    //static const uint32_t JUMPY_EPSILON_DIVISOR = 212;
+
+    /* Number of jumpy points to drop for touchscreens that need it. */
+    //static const uint32_t JUMPY_TRANSITION_DROPS = 3;
+    //static const uint32_t JUMPY_DROP_LIMIT = 3;
+
+    /* Maximum squared distance for averaging.
+     * If moving farther than this, turn of averaging to avoid lag in response. */
+    //static const uint64_t AVERAGING_DISTANCE_LIMIT = 75 * 75;
+
+    /*struct AveragingTouchFilterState {
+        // Individual history tracks are stored by pointer id
+        uint32_t historyStart[MAX_POINTERS];
+        uint32_t historyEnd[MAX_POINTERS];
+        struct {
+            struct {
+                int32_t x;
+                int32_t y;
+                int32_t pressure;
+            } pointers[MAX_POINTERS];
+        } historyData[AVERAGING_HISTORY_SIZE];
+    } mAveragingTouchFilter;
+
+    struct JumpyTouchFilterState {
+        uint32_t jumpyPointsDropped;
+    } mJumpyTouchFilter;*/
+
+    struct PointerDistanceHeapElement {
+        uint32_t currentPointerIndex : 8;
+        uint32_t lastPointerIndex : 8;
+        uint64_t distance : 48; // squared distance
+    };
+
+    void initializeLocked();
+
+    TouchResult consumeOffScreenTouches(nsecs_t when, uint32_t policyFlags);
+    void dispatchTouches(nsecs_t when, uint32_t policyFlags);
+    void dispatchTouch(nsecs_t when, uint32_t policyFlags, TouchData* touch,
+            BitSet32 idBits, uint32_t changedId, uint32_t pointerCount,
+            int32_t motionEventAction);
+
+    bool isPointInsideSurfaceLocked(int32_t x, int32_t y);
+    const VirtualKey* findVirtualKeyHitLocked(int32_t x, int32_t y);
+
+    //bool applyBadTouchFilter();
+    //bool applyJumpyTouchFilter();
+    //void applyAveragingTouchFilter();
+    void calculatePointerIds();
+};
+
+
+class SingleActiveStylusInputMapper : public ActiveStylusInputMapper {
+public:
+    SingleActiveStylusInputMapper(InputDevice* device, int32_t associatedDisplayId);
+    virtual ~SingleActiveStylusInputMapper();
+
+    virtual void reset();
+    virtual void process(const RawEvent* rawEvent);
+
+protected:
+    virtual void configureRawAxes();
+
+private:
+    struct Accumulator {
+        enum {
+            FIELD_BTN_TOUCH = 1,
+            FIELD_ABS_X = 2,
+            FIELD_ABS_Y = 4,
+            FIELD_ABS_PRESSURE = 8,
+            FIELD_ABS_TOOL_WIDTH = 16,
+            FIELD_BTN_TOOL_PEN = 32,
+            FIELD_BTN_TOOL_RUBBER = 64,
+            FIELD_BTN_STYLUS = 128,
+            FIELD_BTN_STYLUS2 = 256
+        };
+
+        uint32_t fields;
+
+        bool btnTouch;
+        int32_t absX;
+        int32_t absY;
+        int32_t absPressure;
+        int32_t absToolWidth;
+        bool btnToolPen;
+        bool btnToolRubber;
+        bool btnStylus;
+        bool btnStylus2;
+
+        inline void clear() {
+            fields = 0;
+        }
+    } mAccumulator;
+
+    bool mDown;
+    int32_t mX;
+    int32_t mY;
+    int32_t mPressure;
+    int32_t mToolWidth;
+    bool mToolPen;
+    bool mToolRubber;
+    bool mButtonStylus;
+    bool mButtonStylus2;
+    bool mInProximity;
+
+    void initialize();
+
+    void sync(nsecs_t when);
+};
+
 } // namespace android
 
 #endif // _UI_INPUT_READER_H
diff --git a/include/ui/InputTransport.h b/include/ui/InputTransport.h
index dc9e27a..7bb824b 100644
--- a/include/ui/InputTransport.h
+++ b/include/ui/InputTransport.h
@@ -134,6 +134,7 @@ struct InputMessage {
 
         struct {
             int32_t action;
+            int32_t toolType;
             int32_t flags;
             int32_t metaState;
             int32_t edgeFlags;
@@ -218,6 +219,7 @@ public:
             int32_t deviceId,
             int32_t source,
             int32_t action,
+            int32_t toolType,
             int32_t flags,
             int32_t edgeFlags,
             int32_t metaState,
diff --git a/include/ui/KeycodeLabels.h b/include/ui/KeycodeLabels.h
index e60efea..301f2e9 100755
--- a/include/ui/KeycodeLabels.h
+++ b/include/ui/KeycodeLabels.h
@@ -135,6 +135,8 @@ static const KeycodeLabel KEYCODES[] = {
     { "BUTTON_START", 108 },
     { "BUTTON_SELECT", 109 },
     { "BUTTON_MODE", 110 },
+    { "BUTTON_STYLUS", 111 },
+    { "BUTTON_STYLUS2", 112 },
 #if defined(VISION_KEYPAD)
     { "USER1", 92 },
     { "USER2", 93 },
diff --git a/libs/ui/EventHub.cpp b/libs/ui/EventHub.cpp
index 41daa9c..7482345 100644
--- a/libs/ui/EventHub.cpp
+++ b/libs/ui/EventHub.cpp
@@ -655,7 +655,7 @@ int EventHub::openDevice(const char *deviceName) {
     mFDs = new_mFDs;
     mDevices = new_devices;
 
-#if 0
+#if 1
     LOGI("add device %d: %s\n", mFDCount, deviceName);
     LOGI("  bus:      %04x\n"
          "  vendor    %04x\n"
@@ -729,8 +729,13 @@ int EventHub::openDevice(const char *deviceName) {
     memset(abs_bitmask, 0, sizeof(abs_bitmask));
     LOGV("Getting absolute controllers...");
     if (ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(abs_bitmask)), abs_bitmask) >= 0) {
+        // Is this an active digitizer driver?
+        if (test_bit(BTN_TOOL_PEN, key_bitmask)
+               && test_bit(ABS_X, abs_bitmask) && test_bit(ABS_Y, abs_bitmask)) {
+            device->classes |= INPUT_DEVICE_CLASS_ACTIVE_DIGITIZER;
+
         // Is this a new modern multi-touch driver?
-        if (test_bit(ABS_MT_POSITION_X, abs_bitmask)
+        } else if (test_bit(ABS_MT_POSITION_X, abs_bitmask)
                 && test_bit(ABS_MT_POSITION_Y, abs_bitmask)) {
             device->classes |= INPUT_DEVICE_CLASS_TOUCHSCREEN | INPUT_DEVICE_CLASS_TOUCHSCREEN_MT;
 
diff --git a/libs/ui/Input.cpp b/libs/ui/Input.cpp
index 811edaf..b7fccc1 100644
--- a/libs/ui/Input.cpp
+++ b/libs/ui/Input.cpp
@@ -129,6 +129,7 @@ void MotionEvent::initialize(
         int32_t deviceId,
         int32_t source,
         int32_t action,
+        int32_t toolType,
         int32_t flags,
         int32_t edgeFlags,
         int32_t metaState,
@@ -143,6 +144,7 @@ void MotionEvent::initialize(
         const PointerCoords* pointerCoords) {
     InputEvent::initialize(deviceId, source);
     mAction = action;
+    mToolType = toolType;
     mFlags = flags;
     mEdgeFlags = edgeFlags;
     mMetaState = metaState;
diff --git a/libs/ui/InputDispatcher.cpp b/libs/ui/InputDispatcher.cpp
index ecaf263..a71b5c5 100644
--- a/libs/ui/InputDispatcher.cpp
+++ b/libs/ui/InputDispatcher.cpp
@@ -8,13 +8,13 @@
 //#define LOG_NDEBUG 0
 
 // Log detailed debug messages about each inbound event notification to the dispatcher.
-#define DEBUG_INBOUND_EVENT_DETAILS 0
+#define DEBUG_INBOUND_EVENT_DETAILS 1
 
 // Log detailed debug messages about each outbound event processed by the dispatcher.
-#define DEBUG_OUTBOUND_EVENT_DETAILS 0
+#define DEBUG_OUTBOUND_EVENT_DETAILS 1
 
 // Log debug messages about batching.
-#define DEBUG_BATCHING 0
+#define DEBUG_BATCHING 1
 
 // Log debug messages about the dispatch cycle.
 #define DEBUG_DISPATCH_CYCLE 0
@@ -23,16 +23,16 @@
 #define DEBUG_REGISTRATION 0
 
 // Log debug messages about performance statistics.
-#define DEBUG_PERFORMANCE_STATISTICS 0
+#define DEBUG_PERFORMANCE_STATISTICS 1
 
 // Log debug messages about input event injection.
-#define DEBUG_INJECTION 0
+#define DEBUG_INJECTION 1
 
 // Log debug messages about input event throttling.
-#define DEBUG_THROTTLING 0
+#define DEBUG_THROTTLING 1
 
 // Log debug messages about input focus tracking.
-#define DEBUG_FOCUS 0
+#define DEBUG_FOCUS 1
 
 // Log debug messages about the app switch latency optimization.
 #define DEBUG_APP_SWITCH 0
@@ -102,6 +102,9 @@ static bool isValidMotionAction(int32_t action, size_t pointerCount) {
     case AMOTION_EVENT_ACTION_CANCEL:
     case AMOTION_EVENT_ACTION_MOVE:
     case AMOTION_EVENT_ACTION_OUTSIDE:
+    case AMOTION_EVENT_ACTION_HOVER:
+    case AMOTION_EVENT_ACTION_ENTER_PROXIMITY:
+    case AMOTION_EVENT_ACTION_EXIT_PROXIMITY:
         return true;
     case AMOTION_EVENT_ACTION_POINTER_DOWN:
     case AMOTION_EVENT_ACTION_POINTER_UP: {
@@ -732,17 +735,22 @@ bool InputDispatcher::dispatchMotionLocked(
     }
 
     bool isPointerEvent = entry->source & AINPUT_SOURCE_CLASS_POINTER;
+    int32_t maskedAction = entry->action & AMOTION_EVENT_ACTION_MASK;
+    bool isNonTouchEvent = (!isPointerEvent) ||
+        (maskedAction == AMOTION_EVENT_ACTION_HOVER) || 
+        (maskedAction == AMOTION_EVENT_ACTION_ENTER_PROXIMITY) ||
+        (maskedAction == AMOTION_EVENT_ACTION_EXIT_PROXIMITY);
 
     // Identify targets.
     if (! mCurrentInputTargetsValid) {
         int32_t injectionResult;
-        if (isPointerEvent) {
-            // Pointer event.  (eg. touchscreen)
-            injectionResult = findTouchedWindowTargetsLocked(currentTime,
+        if (isNonTouchEvent) {
+            // Non touch event.  (eg. trackball, stylus hover, enter/exit proximity)
+            injectionResult = findFocusedWindowTargetsLocked(currentTime,
                     entry, nextWakeupTime);
         } else {
-            // Non touch event.  (eg. trackball)
-            injectionResult = findFocusedWindowTargetsLocked(currentTime,
+            // Touch event.  (eg. touchscreen, standard stylus events)
+            injectionResult = findTouchedWindowTargetsLocked(currentTime,
                     entry, nextWakeupTime);
         }
         if (injectionResult == INPUT_EVENT_INJECTION_PENDING) {
@@ -767,11 +775,11 @@ bool InputDispatcher::dispatchMotionLocked(
 void InputDispatcher::logOutboundMotionDetailsLocked(const char* prefix, const MotionEntry* entry) {
 #if DEBUG_OUTBOUND_EVENT_DETAILS
     LOGD("%seventTime=%lld, deviceId=0x%x, source=0x%x, policyFlags=0x%x, "
-            "action=0x%x, flags=0x%x, "
+            "action=0x%x, toolType=0x%x, flags=0x%x, "
             "metaState=0x%x, edgeFlags=0x%x, xPrecision=%f, yPrecision=%f, downTime=%lld",
             prefix,
             entry->eventTime, entry->deviceId, entry->source, entry->policyFlags,
-            entry->action, entry->flags,
+            entry->action, entry->toolType, entry->flags,
             entry->metaState, entry->edgeFlags, entry->xPrecision, entry->yPrecision,
             entry->downTime);
 
@@ -1659,6 +1667,7 @@ void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime,
 
         // Apply target flags.
         int32_t action = motionEntry->action;
+        int32_t toolType = motionEntry->toolType;
         int32_t flags = motionEntry->flags;
         if (dispatchEntry->targetFlags & InputTarget::FLAG_OUTSIDE) {
             action = AMOTION_EVENT_ACTION_OUTSIDE;
@@ -1688,7 +1697,7 @@ void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime,
 
         // Publish the motion event and the first motion sample.
         status = connection->inputPublisher.publishMotionEvent(motionEntry->deviceId,
-                motionEntry->source, action, flags, motionEntry->edgeFlags, motionEntry->metaState,
+                motionEntry->source, action, toolType, flags, motionEntry->edgeFlags, motionEntry->metaState,
                 xOffset, yOffset,
                 motionEntry->xPrecision, motionEntry->yPrecision,
                 motionEntry->downTime, firstMotionSample->eventTime,
@@ -2023,6 +2032,7 @@ InputDispatcher::splitMotionEvent(const MotionEntry* originalMotionEntry, BitSet
             originalMotionEntry->source,
             originalMotionEntry->policyFlags,
             action,
+            originalMotionEntry->toolType,
             originalMotionEntry->flags,
             originalMotionEntry->metaState,
             originalMotionEntry->edgeFlags,
@@ -2100,14 +2110,14 @@ void InputDispatcher::notifyKey(nsecs_t eventTime, int32_t deviceId, int32_t sou
 }
 
 void InputDispatcher::notifyMotion(nsecs_t eventTime, int32_t deviceId, int32_t source,
-        uint32_t policyFlags, int32_t action, int32_t flags, int32_t metaState, int32_t edgeFlags,
+        uint32_t policyFlags, int32_t action, int32_t toolType, int32_t flags, int32_t metaState, int32_t edgeFlags,
         uint32_t pointerCount, const int32_t* pointerIds, const PointerCoords* pointerCoords,
         float xPrecision, float yPrecision, nsecs_t downTime) {
 #if DEBUG_INBOUND_EVENT_DETAILS
     LOGD("notifyMotion - eventTime=%lld, deviceId=0x%x, source=0x%x, policyFlags=0x%x, "
-            "action=0x%x, flags=0x%x, metaState=0x%x, edgeFlags=0x%x, "
+            "action=0x%x, toolType=0x%x, flags=0x%x, metaState=0x%x, edgeFlags=0x%x, "
             "xPrecision=%f, yPrecision=%f, downTime=%lld",
-            eventTime, deviceId, source, policyFlags, action, flags, metaState, edgeFlags,
+            eventTime, deviceId, source, policyFlags, action, toolType, flags, metaState, edgeFlags,
             xPrecision, yPrecision, downTime);
     for (uint32_t i = 0; i < pointerCount; i++) {
         LOGD("  Pointer %d: id=%d, x=%f, y=%f, pressure=%f, size=%f, "
@@ -2136,6 +2146,8 @@ void InputDispatcher::notifyMotion(nsecs_t eventTime, int32_t deviceId, int32_t
     { // acquire lock
         AutoMutex _l(mLock);
 
+        // TODO: do we want to try to batch/steam hover events as well?
+
         // Attempt batching and streaming of move events.
         if (action == AMOTION_EVENT_ACTION_MOVE) {
             // BATCHING CASE
@@ -2244,7 +2256,7 @@ NoBatchingOrStreaming:;
 
         // Just enqueue a new motion event.
         MotionEntry* newEntry = mAllocator.obtainMotionEntry(eventTime,
-                deviceId, source, policyFlags, action, flags, metaState, edgeFlags,
+                deviceId, source, policyFlags, action, toolType, flags, metaState, edgeFlags,
                 xPrecision, yPrecision, downTime,
                 pointerCount, pointerIds, pointerCoords);
 
@@ -2309,6 +2321,7 @@ int32_t InputDispatcher::injectInputEvent(const InputEvent* event,
     case AINPUT_EVENT_TYPE_MOTION: {
         const MotionEvent* motionEvent = static_cast<const MotionEvent*>(event);
         int32_t action = motionEvent->getAction();
+        int32_t toolType = motionEvent->getToolType();
         size_t pointerCount = motionEvent->getPointerCount();
         const int32_t* pointerIds = motionEvent->getPointerIds();
         if (! validateMotionEvent(action, pointerCount, pointerIds)) {
@@ -2323,7 +2336,7 @@ int32_t InputDispatcher::injectInputEvent(const InputEvent* event,
         const PointerCoords* samplePointerCoords = motionEvent->getSamplePointerCoords();
         MotionEntry* motionEntry = mAllocator.obtainMotionEntry(*sampleEventTimes,
                 motionEvent->getDeviceId(), motionEvent->getSource(), policyFlags,
-                action, motionEvent->getFlags(),
+                action, toolType, motionEvent->getFlags(),
                 motionEvent->getMetaState(), motionEvent->getEdgeFlags(),
                 motionEvent->getXPrecision(), motionEvent->getYPrecision(),
                 motionEvent->getDownTime(), uint32_t(pointerCount),
@@ -3037,7 +3050,7 @@ InputDispatcher::KeyEntry* InputDispatcher::Allocator::obtainKeyEntry(nsecs_t ev
 }
 
 InputDispatcher::MotionEntry* InputDispatcher::Allocator::obtainMotionEntry(nsecs_t eventTime,
-        int32_t deviceId, int32_t source, uint32_t policyFlags, int32_t action, int32_t flags,
+        int32_t deviceId, int32_t source, uint32_t policyFlags, int32_t action, int32_t toolType, int32_t flags,
         int32_t metaState, int32_t edgeFlags, float xPrecision, float yPrecision,
         nsecs_t downTime, uint32_t pointerCount,
         const int32_t* pointerIds, const PointerCoords* pointerCoords) {
@@ -3048,6 +3061,7 @@ InputDispatcher::MotionEntry* InputDispatcher::Allocator::obtainMotionEntry(nsec
     entry->deviceId = deviceId;
     entry->source = source;
     entry->action = action;
+    entry->toolType = toolType;
     entry->flags = flags;
     entry->metaState = metaState;
     entry->edgeFlags = edgeFlags;
@@ -3292,6 +3306,11 @@ InputDispatcher::InputState::Consistency InputDispatcher::InputState::trackMotio
                     return CONSISTENT;
                 }
                 return BROKEN;
+            case AMOTION_EVENT_ACTION_HOVER:
+                return CONSISTENT;
+            case AMOTION_EVENT_ACTION_ENTER_PROXIMITY:
+            case AMOTION_EVENT_ACTION_EXIT_PROXIMITY:
+                return CONSISTENT;
 
             default:
                 return BROKEN;
@@ -3311,6 +3330,11 @@ InputDispatcher::InputState::Consistency InputDispatcher::InputState::trackMotio
         memento.setPointers(entry);
         return CONSISTENT;
     }
+    case AMOTION_EVENT_ACTION_HOVER:
+        return CONSISTENT;
+    case AMOTION_EVENT_ACTION_ENTER_PROXIMITY:
+    case AMOTION_EVENT_ACTION_EXIT_PROXIMITY:
+        return CONSISTENT;
 
     default:
         return BROKEN;
@@ -3346,7 +3370,7 @@ void InputDispatcher::InputState::synthesizeCancelationEvents(nsecs_t currentTim
         if (shouldCancelEvent(memento.source, options)) {
             outEvents.push(allocator->obtainMotionEntry(currentTime,
                     memento.deviceId, memento.source, 0,
-                    AMOTION_EVENT_ACTION_CANCEL, 0, 0, 0,
+                    AMOTION_EVENT_ACTION_CANCEL, 0, 0, 0, 0,
                     memento.xPrecision, memento.yPrecision, memento.downTime,
                     memento.pointerCount, memento.pointerIds, memento.pointerCoords));
             mMotionMementos.removeAt(i);
diff --git a/libs/ui/InputReader.cpp b/libs/ui/InputReader.cpp
index 3197ab2..2fbd5db 100644
--- a/libs/ui/InputReader.cpp
+++ b/libs/ui/InputReader.cpp
@@ -89,6 +89,12 @@ int32_t updateMetaState(int32_t keyCode, bool down, int32_t oldMetaState) {
     case AKEYCODE_SYM:
         mask = AMETA_SYM_ON;
         break;
+    case AKEYCODE_BUTTON_STYLUS:
+        mask = AMETA_BTN_STYLUS_ON;
+        break;
+    case AKEYCODE_BUTTON_STYLUS2:
+        mask = AMETA_BTN_STYLUS2_ON;
+        break;
     default:
         return oldMetaState;
     }
@@ -347,6 +353,11 @@ InputDevice* InputReader::createDevice(int32_t deviceId, const String8& name, ui
         device->addMapper(new SingleTouchInputMapper(device, associatedDisplayId));
     }
 
+    // Active digitizer-like devices.
+    if (classes & INPUT_DEVICE_CLASS_ACTIVE_DIGITIZER) {
+        device->addMapper(new SingleActiveStylusInputMapper(device, associatedDisplayId));
+    }
+
     return device;
 }
 
@@ -1189,7 +1200,7 @@ void TrackballInputMapper::sync(nsecs_t when) {
     int32_t metaState = mContext->getGlobalMetaState();
     int32_t pointerId = 0;
     getDispatcher()->notifyMotion(when, getDeviceId(), AINPUT_SOURCE_TRACKBALL, 0,
-            motionEventAction, 0, metaState, AMOTION_EVENT_EDGE_FLAG_NONE,
+            motionEventAction, AMOTION_EVENT_TOOL_TYPE_NONE, 0, metaState, AMOTION_EVENT_EDGE_FLAG_NONE,
             1, &pointerId, &pointerCoords, mXPrecision, mYPrecision, downTime);
 
     mAccumulator.clear();
@@ -2490,7 +2501,7 @@ void TouchInputMapper::dispatchTouch(nsecs_t when, uint32_t policyFlags,
     } // release lock
 
     getDispatcher()->notifyMotion(when, getDeviceId(), getSources(), policyFlags,
-            motionEventAction, 0, getContext()->getGlobalMetaState(), motionEventEdgeFlags,
+            motionEventAction, AMOTION_EVENT_TOOL_TYPE_NONE, 0, getContext()->getGlobalMetaState(), motionEventEdgeFlags,
             pointerCount, pointerIds, pointerCoords,
             xPrecision, yPrecision, mDownTime);
 }
@@ -3474,5 +3485,2364 @@ void MultiTouchInputMapper::configureRawAxes() {
     getEventHub()->getAbsoluteAxisInfo(getDeviceId(), ABS_MT_PRESSURE, & mRawAxes.pressure);
 }
 
+// --- ActiveStylusInputMapper ---
+
+ActiveStylusInputMapper::ActiveStylusInputMapper(InputDevice* device, int32_t associatedDisplayId) :
+        InputMapper(device), mAssociatedDisplayId(associatedDisplayId) {
+    mLocked.surfaceOrientation = -1;
+    mLocked.surfaceWidth = -1;
+    mLocked.surfaceHeight = -1;
+
+    initializeLocked();
+}
+
+ActiveStylusInputMapper::~ActiveStylusInputMapper() {
+}
+
+uint32_t ActiveStylusInputMapper::getSources() {
+    return AINPUT_SOURCE_ACTIVE_STYLUS;
+}
+
+void ActiveStylusInputMapper::populateDeviceInfo(InputDeviceInfo* info) {
+    InputMapper::populateDeviceInfo(info);
+
+    { // acquire lock
+        AutoMutex _l(mLock);
+
+        // Ensure surface information is up to date so that orientation changes are
+        // noticed immediately.
+        configureSurfaceLocked();
+
+        info->addMotionRange(AINPUT_MOTION_RANGE_X, mLocked.orientedRanges.x);
+        info->addMotionRange(AINPUT_MOTION_RANGE_Y, mLocked.orientedRanges.y);
+
+        if (mLocked.orientedRanges.havePressure) {
+            info->addMotionRange(AINPUT_MOTION_RANGE_PRESSURE,
+                    mLocked.orientedRanges.pressure);
+        }
+
+        if (mLocked.orientedRanges.haveSize) {
+            info->addMotionRange(AINPUT_MOTION_RANGE_SIZE,
+                    mLocked.orientedRanges.size);
+        }
+
+        if (mLocked.orientedRanges.haveTouchSize) {
+            info->addMotionRange(AINPUT_MOTION_RANGE_TOUCH_MAJOR,
+                    mLocked.orientedRanges.touchMajor);
+            info->addMotionRange(AINPUT_MOTION_RANGE_TOUCH_MINOR,
+                    mLocked.orientedRanges.touchMinor);
+        }
+
+        if (mLocked.orientedRanges.haveToolSize) {
+            info->addMotionRange(AINPUT_MOTION_RANGE_TOOL_MAJOR,
+                    mLocked.orientedRanges.toolMajor);
+            info->addMotionRange(AINPUT_MOTION_RANGE_TOOL_MINOR,
+                    mLocked.orientedRanges.toolMinor);
+        }
+
+        if (mLocked.orientedRanges.haveOrientation) {
+            info->addMotionRange(AINPUT_MOTION_RANGE_ORIENTATION,
+                    mLocked.orientedRanges.orientation);
+        }
+    } // release lock
+}
+
+void ActiveStylusInputMapper::dump(String8& dump) {
+    { // acquire lock
+        AutoMutex _l(mLock);
+        dump.append(INDENT2 "Active Stylus Input Mapper:\n");
+        dump.appendFormat(INDENT3 "AssociatedDisplayId: %d\n", mAssociatedDisplayId);
+        //dumpParameters(dump);
+        dumpVirtualKeysLocked(dump);
+        dumpRawAxes(dump);
+        dumpCalibration(dump);
+        dumpSurfaceLocked(dump);
+        dump.appendFormat(INDENT3 "Translation and Scaling Factors:");
+        dump.appendFormat(INDENT4 "XOrigin: %d\n", mLocked.xOrigin);
+        dump.appendFormat(INDENT4 "YOrigin: %d\n", mLocked.yOrigin);
+        dump.appendFormat(INDENT4 "XScale: %0.3f\n", mLocked.xScale);
+        dump.appendFormat(INDENT4 "YScale: %0.3f\n", mLocked.yScale);
+        dump.appendFormat(INDENT4 "XPrecision: %0.3f\n", mLocked.xPrecision);
+        dump.appendFormat(INDENT4 "YPrecision: %0.3f\n", mLocked.yPrecision);
+        dump.appendFormat(INDENT4 "GeometricScale: %0.3f\n", mLocked.geometricScale);
+        dump.appendFormat(INDENT4 "ToolSizeLinearScale: %0.3f\n", mLocked.toolSizeLinearScale);
+        dump.appendFormat(INDENT4 "ToolSizeLinearBias: %0.3f\n", mLocked.toolSizeLinearBias);
+        dump.appendFormat(INDENT4 "ToolSizeAreaScale: %0.3f\n", mLocked.toolSizeAreaScale);
+        dump.appendFormat(INDENT4 "ToolSizeAreaBias: %0.3f\n", mLocked.toolSizeAreaBias);
+        dump.appendFormat(INDENT4 "PressureScale: %0.3f\n", mLocked.pressureScale);
+        dump.appendFormat(INDENT4 "SizeScale: %0.3f\n", mLocked.sizeScale);
+        dump.appendFormat(INDENT4 "OrientationSCale: %0.3f\n", mLocked.orientationScale);
+    } // release lock
+}
+
+void ActiveStylusInputMapper::initializeLocked() {
+    mCurrentTouch.clear();
+    mLastTouch.clear();
+    mDownTime = 0;
+    
+    mLocked.metaState = AMETA_NONE;
+
+    /*for (uint32_t i = 0; i < MAX_POINTERS; i++) {
+        mAveragingTouchFilter.historyStart[i] = 0;
+        mAveragingTouchFilter.historyEnd[i] = 0;
+    }*/
+
+    //mJumpyTouchFilter.jumpyPointsDropped = 0;
+
+    mLocked.currentVirtualKey.down = false;
+
+    mLocked.orientedRanges.havePressure = false;
+    mLocked.orientedRanges.haveSize = false;
+    mLocked.orientedRanges.haveTouchSize = false;
+    mLocked.orientedRanges.haveToolSize = false;
+    mLocked.orientedRanges.haveOrientation = false;
+}
+
+void ActiveStylusInputMapper::configure() {
+    InputMapper::configure();
+
+    // Configure basic parameters.
+    //configureParameters();
+
+    // Configure absolute axis information.
+    configureRawAxes();
+
+    // Prepare input device calibration.
+    parseCalibration();
+    resolveCalibration();
+
+    { // acquire lock
+        AutoMutex _l(mLock);
+
+         // Configure surface dimensions and orientation.
+        configureSurfaceLocked();
+    } // release lock
+}
+
+/*void ActiveStylusInputMapper::configureParameters() {
+    mParameters.useBadTouchFilter = getPolicy()->filterTouchEvents();
+    mParameters.useAveragingTouchFilter = getPolicy()->filterTouchEvents();
+    mParameters.useJumpyTouchFilter = getPolicy()->filterJumpyTouchEvents();
+}*/
+
+/*void ActiveStylusInputMapper::dumpParameters(String8& dump) {
+    dump.appendFormat(INDENT3 "UseBadTouchFilter: %s\n",
+            toString(mParameters.useBadTouchFilter));
+    dump.appendFormat(INDENT3 "UseAveragingTouchFilter: %s\n",
+            toString(mParameters.useAveragingTouchFilter));
+    dump.appendFormat(INDENT3 "UseJumpyTouchFilter: %s\n",
+            toString(mParameters.useJumpyTouchFilter));
+}*/
+
+void ActiveStylusInputMapper::configureRawAxes() {
+    mRawAxes.x.clear();
+    mRawAxes.y.clear();
+    mRawAxes.pressure.clear();
+    mRawAxes.touchMajor.clear();
+    mRawAxes.touchMinor.clear();
+    mRawAxes.toolMajor.clear();
+    mRawAxes.toolMinor.clear();
+    mRawAxes.orientation.clear();
+}
+
+void ActiveStylusInputMapper::dumpRawAxes(String8& dump) {
+    dump.append(INDENT3 "Raw Axes:\n");
+    dumpAxisInfo(dump, mRawAxes.x, "X");
+    dumpAxisInfo(dump, mRawAxes.y, "Y");
+    dumpAxisInfo(dump, mRawAxes.pressure, "Pressure");
+    dumpAxisInfo(dump, mRawAxes.touchMajor, "TouchMajor");
+    dumpAxisInfo(dump, mRawAxes.touchMinor, "TouchMinor");
+    dumpAxisInfo(dump, mRawAxes.toolMajor, "ToolMajor");
+    dumpAxisInfo(dump, mRawAxes.toolMinor, "ToolMinor");
+    dumpAxisInfo(dump, mRawAxes.orientation, "Orientation");
+}
+
+bool ActiveStylusInputMapper::configureSurfaceLocked() {
+    // Update orientation and dimensions if needed.
+    int32_t orientation;
+    int32_t width, height;
+    if (mAssociatedDisplayId >= 0) {
+        // Note: getDisplayInfo is non-reentrant so we can continue holding the lock.
+        if (! getPolicy()->getDisplayInfo(mAssociatedDisplayId, & width, & height, & orientation)) {
+            return false;
+        }
+    } else {
+        orientation = InputReaderPolicyInterface::ROTATION_0;
+        width = mRawAxes.x.getRange();
+        height = mRawAxes.y.getRange();
+    }
+
+    bool orientationChanged = mLocked.surfaceOrientation != orientation;
+    if (orientationChanged) {
+        mLocked.surfaceOrientation = orientation;
+    }
+
+    bool sizeChanged = mLocked.surfaceWidth != width || mLocked.surfaceHeight != height;
+    if (sizeChanged) {
+        LOGI("Device reconfigured: id=0x%x, name=%s, display size is now %dx%d",
+                getDeviceId(), getDeviceName().string(), width, height);
+
+        mLocked.surfaceWidth = width;
+        mLocked.surfaceHeight = height;
+
+        // Configure X and Y factors.
+        if (mRawAxes.x.valid && mRawAxes.y.valid) {
+            mLocked.xOrigin = mRawAxes.x.minValue;
+            mLocked.yOrigin = mRawAxes.y.minValue;
+            mLocked.xScale = float(width) / mRawAxes.x.getRange();
+            mLocked.yScale = float(height) / mRawAxes.y.getRange();
+            mLocked.xPrecision = 1.0f / mLocked.xScale;
+            mLocked.yPrecision = 1.0f / mLocked.yScale;
+
+            configureVirtualKeysLocked();
+        } else {
+            LOGW(INDENT "Active digitizer did not report support for X or Y axis!");
+            mLocked.xOrigin = 0;
+            mLocked.yOrigin = 0;
+            mLocked.xScale = 1.0f;
+            mLocked.yScale = 1.0f;
+            mLocked.xPrecision = 1.0f;
+            mLocked.yPrecision = 1.0f;
+        }
+
+        // Scale factor for terms that are not oriented in a particular axis.
+        // If the pixels are square then xScale == yScale otherwise we fake it
+        // by choosing an average.
+        mLocked.geometricScale = avg(mLocked.xScale, mLocked.yScale);
+
+        // Size of diagonal axis.
+        float diagonalSize = pythag(width, height);
+
+        // TouchMajor and TouchMinor factors.
+        if (mCalibration.touchSizeCalibration != Calibration::TOUCH_SIZE_CALIBRATION_NONE) {
+            mLocked.orientedRanges.haveTouchSize = true;
+            mLocked.orientedRanges.touchMajor.min = 0;
+            mLocked.orientedRanges.touchMajor.max = diagonalSize;
+            mLocked.orientedRanges.touchMajor.flat = 0;
+            mLocked.orientedRanges.touchMajor.fuzz = 0;
+            mLocked.orientedRanges.touchMinor = mLocked.orientedRanges.touchMajor;
+        }
+
+        // ToolMajor and ToolMinor factors.
+        mLocked.toolSizeLinearScale = 0;
+        mLocked.toolSizeLinearBias = 0;
+        mLocked.toolSizeAreaScale = 0;
+        mLocked.toolSizeAreaBias = 0;
+        if (mCalibration.toolSizeCalibration != Calibration::TOOL_SIZE_CALIBRATION_NONE) {
+            if (mCalibration.toolSizeCalibration == Calibration::TOOL_SIZE_CALIBRATION_LINEAR) {
+                if (mCalibration.haveToolSizeLinearScale) {
+                    mLocked.toolSizeLinearScale = mCalibration.toolSizeLinearScale;
+                } else if (mRawAxes.toolMajor.valid && mRawAxes.toolMajor.maxValue != 0) {
+                    mLocked.toolSizeLinearScale = float(min(width, height))
+                            / mRawAxes.toolMajor.maxValue;
+                }
+
+                if (mCalibration.haveToolSizeLinearBias) {
+                    mLocked.toolSizeLinearBias = mCalibration.toolSizeLinearBias;
+                }
+            } else if (mCalibration.toolSizeCalibration ==
+                    Calibration::TOOL_SIZE_CALIBRATION_AREA) {
+                if (mCalibration.haveToolSizeLinearScale) {
+                    mLocked.toolSizeLinearScale = mCalibration.toolSizeLinearScale;
+                } else {
+                    mLocked.toolSizeLinearScale = min(width, height);
+                }
+
+                if (mCalibration.haveToolSizeLinearBias) {
+                    mLocked.toolSizeLinearBias = mCalibration.toolSizeLinearBias;
+                }
+
+                if (mCalibration.haveToolSizeAreaScale) {
+                    mLocked.toolSizeAreaScale = mCalibration.toolSizeAreaScale;
+                } else if (mRawAxes.toolMajor.valid && mRawAxes.toolMajor.maxValue != 0) {
+                    mLocked.toolSizeAreaScale = 1.0f / mRawAxes.toolMajor.maxValue;
+                }
+
+                if (mCalibration.haveToolSizeAreaBias) {
+                    mLocked.toolSizeAreaBias = mCalibration.toolSizeAreaBias;
+                }
+            }
+
+            mLocked.orientedRanges.haveToolSize = true;
+            mLocked.orientedRanges.toolMajor.min = 0;
+            mLocked.orientedRanges.toolMajor.max = diagonalSize;
+            mLocked.orientedRanges.toolMajor.flat = 0;
+            mLocked.orientedRanges.toolMajor.fuzz = 0;
+            mLocked.orientedRanges.toolMinor = mLocked.orientedRanges.toolMajor;
+        }
+
+        // Pressure factors.
+        mLocked.pressureScale = 0;
+        if (mCalibration.pressureCalibration != Calibration::PRESSURE_CALIBRATION_NONE) {
+            RawAbsoluteAxisInfo rawPressureAxis;
+            switch (mCalibration.pressureSource) {
+            case Calibration::PRESSURE_SOURCE_PRESSURE:
+                rawPressureAxis = mRawAxes.pressure;
+                break;
+            case Calibration::PRESSURE_SOURCE_TOUCH:
+                rawPressureAxis = mRawAxes.touchMajor;
+                break;
+            default:
+                rawPressureAxis.clear();
+            }
+
+            if (mCalibration.pressureCalibration == Calibration::PRESSURE_CALIBRATION_PHYSICAL
+                    || mCalibration.pressureCalibration
+                            == Calibration::PRESSURE_CALIBRATION_AMPLITUDE) {
+                if (mCalibration.havePressureScale) {
+                    mLocked.pressureScale = mCalibration.pressureScale;
+                } else if (rawPressureAxis.valid && rawPressureAxis.maxValue != 0) {
+                    mLocked.pressureScale = 1.0f / rawPressureAxis.maxValue;
+                }
+            }
+
+            mLocked.orientedRanges.havePressure = true;
+            mLocked.orientedRanges.pressure.min = 0;
+            mLocked.orientedRanges.pressure.max = 1.0;
+            mLocked.orientedRanges.pressure.flat = 0;
+            mLocked.orientedRanges.pressure.fuzz = 0;
+        }
+
+        // Size factors.
+        mLocked.sizeScale = 0;
+        if (mCalibration.sizeCalibration != Calibration::SIZE_CALIBRATION_NONE) {
+            if (mCalibration.sizeCalibration == Calibration::SIZE_CALIBRATION_NORMALIZED) {
+                if (mRawAxes.toolMajor.valid && mRawAxes.toolMajor.maxValue != 0) {
+                    mLocked.sizeScale = 1.0f / mRawAxes.toolMajor.maxValue;
+                }
+            }
+
+            mLocked.orientedRanges.haveSize = true;
+            mLocked.orientedRanges.size.min = 0;
+            mLocked.orientedRanges.size.max = 1.0;
+            mLocked.orientedRanges.size.flat = 0;
+            mLocked.orientedRanges.size.fuzz = 0;
+        }
+
+        // Orientation
+        mLocked.orientationScale = 0;
+        if (mCalibration.orientationCalibration != Calibration::ORIENTATION_CALIBRATION_NONE) {
+            if (mCalibration.orientationCalibration
+                    == Calibration::ORIENTATION_CALIBRATION_INTERPOLATED) {
+                if (mRawAxes.orientation.valid && mRawAxes.orientation.maxValue != 0) {
+                    mLocked.orientationScale = float(M_PI_2) / mRawAxes.orientation.maxValue;
+                }
+            }
+
+            mLocked.orientedRanges.orientation.min = - M_PI_2;
+            mLocked.orientedRanges.orientation.max = M_PI_2;
+            mLocked.orientedRanges.orientation.flat = 0;
+            mLocked.orientedRanges.orientation.fuzz = 0;
+        }
+    }
+
+    if (orientationChanged || sizeChanged) {
+        // Compute oriented surface dimensions, precision, and scales.
+        float orientedXScale, orientedYScale;
+        switch (mLocked.surfaceOrientation) {
+        case InputReaderPolicyInterface::ROTATION_90:
+        case InputReaderPolicyInterface::ROTATION_270:
+            mLocked.orientedSurfaceWidth = mLocked.surfaceHeight;
+            mLocked.orientedSurfaceHeight = mLocked.surfaceWidth;
+            mLocked.orientedXPrecision = mLocked.yPrecision;
+            mLocked.orientedYPrecision = mLocked.xPrecision;
+            orientedXScale = mLocked.yScale;
+            orientedYScale = mLocked.xScale;
+            break;
+        default:
+            mLocked.orientedSurfaceWidth = mLocked.surfaceWidth;
+            mLocked.orientedSurfaceHeight = mLocked.surfaceHeight;
+            mLocked.orientedXPrecision = mLocked.xPrecision;
+            mLocked.orientedYPrecision = mLocked.yPrecision;
+            orientedXScale = mLocked.xScale;
+            orientedYScale = mLocked.yScale;
+            break;
+        }
+
+        // Configure position ranges.
+        mLocked.orientedRanges.x.min = 0;
+        mLocked.orientedRanges.x.max = mLocked.orientedSurfaceWidth;
+        mLocked.orientedRanges.x.flat = 0;
+        mLocked.orientedRanges.x.fuzz = orientedXScale;
+
+        mLocked.orientedRanges.y.min = 0;
+        mLocked.orientedRanges.y.max = mLocked.orientedSurfaceHeight;
+        mLocked.orientedRanges.y.flat = 0;
+        mLocked.orientedRanges.y.fuzz = orientedYScale;
+    }
+
+    return true;
+}
+
+void ActiveStylusInputMapper::dumpSurfaceLocked(String8& dump) {
+    dump.appendFormat(INDENT3 "SurfaceWidth: %dpx\n", mLocked.surfaceWidth);
+    dump.appendFormat(INDENT3 "SurfaceHeight: %dpx\n", mLocked.surfaceHeight);
+    dump.appendFormat(INDENT3 "SurfaceOrientation: %d\n", mLocked.surfaceOrientation);
+}
+
+void ActiveStylusInputMapper::configureVirtualKeysLocked() {
+    assert(mRawAxes.x.valid && mRawAxes.y.valid);
+
+    // Note: getVirtualKeyDefinitions is non-reentrant so we can continue holding the lock.
+    Vector<VirtualKeyDefinition> virtualKeyDefinitions;
+    getPolicy()->getVirtualKeyDefinitions(getDeviceName(), virtualKeyDefinitions);
+
+    mLocked.virtualKeys.clear();
+
+    if (virtualKeyDefinitions.size() == 0) {
+        return;
+    }
+
+    mLocked.virtualKeys.setCapacity(virtualKeyDefinitions.size());
+
+    int32_t touchScreenLeft = mRawAxes.x.minValue;
+    int32_t touchScreenTop = mRawAxes.y.minValue;
+    int32_t touchScreenWidth = mRawAxes.x.getRange();
+    int32_t touchScreenHeight = mRawAxes.y.getRange();
+
+    for (size_t i = 0; i < virtualKeyDefinitions.size(); i++) {
+        const VirtualKeyDefinition& virtualKeyDefinition =
+                virtualKeyDefinitions[i];
+
+        mLocked.virtualKeys.add();
+        VirtualKey& virtualKey = mLocked.virtualKeys.editTop();
+
+        virtualKey.scanCode = virtualKeyDefinition.scanCode;
+        int32_t keyCode;
+        uint32_t flags;
+        if (getEventHub()->scancodeToKeycode(getDeviceId(), virtualKey.scanCode,
+                & keyCode, & flags)) {
+            LOGW(INDENT "VirtualKey %d: could not obtain key code, ignoring",
+                    virtualKey.scanCode);
+            mLocked.virtualKeys.pop(); // drop the key
+            continue;
+        }
+
+        virtualKey.keyCode = keyCode;
+        virtualKey.flags = flags;
+
+        // convert the key definition's display coordinates into touch coordinates for a hit box
+        int32_t halfWidth = virtualKeyDefinition.width / 2;
+        int32_t halfHeight = virtualKeyDefinition.height / 2;
+
+        virtualKey.hitLeft = (virtualKeyDefinition.centerX - halfWidth)
+                * touchScreenWidth / mLocked.surfaceWidth + touchScreenLeft;
+        virtualKey.hitRight= (virtualKeyDefinition.centerX + halfWidth)
+                * touchScreenWidth / mLocked.surfaceWidth + touchScreenLeft;
+        virtualKey.hitTop = (virtualKeyDefinition.centerY - halfHeight)
+                * touchScreenHeight / mLocked.surfaceHeight + touchScreenTop;
+        virtualKey.hitBottom = (virtualKeyDefinition.centerY + halfHeight)
+                * touchScreenHeight / mLocked.surfaceHeight + touchScreenTop;
+
+    }
+}
+
+void ActiveStylusInputMapper::dumpVirtualKeysLocked(String8& dump) {
+    if (!mLocked.virtualKeys.isEmpty()) {
+        dump.append(INDENT3 "Virtual Keys:\n");
+
+        for (size_t i = 0; i < mLocked.virtualKeys.size(); i++) {
+            const VirtualKey& virtualKey = mLocked.virtualKeys.itemAt(i);
+            dump.appendFormat(INDENT4 "%d: scanCode=%d, keyCode=%d, "
+                    "hitLeft=%d, hitRight=%d, hitTop=%d, hitBottom=%d\n",
+                    i, virtualKey.scanCode, virtualKey.keyCode,
+                    virtualKey.hitLeft, virtualKey.hitRight,
+                    virtualKey.hitTop, virtualKey.hitBottom);
+        }
+    }
+}
+
+void ActiveStylusInputMapper::parseCalibration() {
+    const InputDeviceCalibration& in = getDevice()->getCalibration();
+    Calibration& out = mCalibration;
+
+    // Touch Size
+    out.touchSizeCalibration = Calibration::TOUCH_SIZE_CALIBRATION_DEFAULT;
+    String8 touchSizeCalibrationString;
+    if (in.tryGetProperty(String8("touch.touchSize.calibration"), touchSizeCalibrationString)) {
+        if (touchSizeCalibrationString == "none") {
+            out.touchSizeCalibration = Calibration::TOUCH_SIZE_CALIBRATION_NONE;
+        } else if (touchSizeCalibrationString == "geometric") {
+            out.touchSizeCalibration = Calibration::TOUCH_SIZE_CALIBRATION_GEOMETRIC;
+        } else if (touchSizeCalibrationString == "pressure") {
+            out.touchSizeCalibration = Calibration::TOUCH_SIZE_CALIBRATION_PRESSURE;
+        } else if (touchSizeCalibrationString != "default") {
+            LOGW("Invalid value for touch.touchSize.calibration: '%s'",
+                    touchSizeCalibrationString.string());
+        }
+    }
+
+    // Tool Size
+    out.toolSizeCalibration = Calibration::TOOL_SIZE_CALIBRATION_DEFAULT;
+    String8 toolSizeCalibrationString;
+    if (in.tryGetProperty(String8("touch.toolSize.calibration"), toolSizeCalibrationString)) {
+        if (toolSizeCalibrationString == "none") {
+            out.toolSizeCalibration = Calibration::TOOL_SIZE_CALIBRATION_NONE;
+        } else if (toolSizeCalibrationString == "geometric") {
+            out.toolSizeCalibration = Calibration::TOOL_SIZE_CALIBRATION_GEOMETRIC;
+        } else if (toolSizeCalibrationString == "linear") {
+            out.toolSizeCalibration = Calibration::TOOL_SIZE_CALIBRATION_LINEAR;
+        } else if (toolSizeCalibrationString == "area") {
+            out.toolSizeCalibration = Calibration::TOOL_SIZE_CALIBRATION_AREA;
+        } else if (toolSizeCalibrationString != "default") {
+            LOGW("Invalid value for touch.toolSize.calibration: '%s'",
+                    toolSizeCalibrationString.string());
+        }
+    }
+
+    out.haveToolSizeLinearScale = in.tryGetProperty(String8("touch.toolSize.linearScale"),
+            out.toolSizeLinearScale);
+    out.haveToolSizeLinearBias = in.tryGetProperty(String8("touch.toolSize.linearBias"),
+            out.toolSizeLinearBias);
+    out.haveToolSizeAreaScale = in.tryGetProperty(String8("touch.toolSize.areaScale"),
+            out.toolSizeAreaScale);
+    out.haveToolSizeAreaBias = in.tryGetProperty(String8("touch.toolSize.areaBias"),
+            out.toolSizeAreaBias);
+    out.haveToolSizeIsSummed = in.tryGetProperty(String8("touch.toolSize.isSummed"),
+            out.toolSizeIsSummed);
+
+    // Pressure
+    out.pressureCalibration = Calibration::PRESSURE_CALIBRATION_DEFAULT;
+    String8 pressureCalibrationString;
+    if (in.tryGetProperty(String8("touch.pressure.calibration"), pressureCalibrationString)) {
+        if (pressureCalibrationString == "none") {
+            out.pressureCalibration = Calibration::PRESSURE_CALIBRATION_NONE;
+        } else if (pressureCalibrationString == "physical") {
+            out.pressureCalibration = Calibration::PRESSURE_CALIBRATION_PHYSICAL;
+        } else if (pressureCalibrationString == "amplitude") {
+            out.pressureCalibration = Calibration::PRESSURE_CALIBRATION_AMPLITUDE;
+        } else if (pressureCalibrationString != "default") {
+            LOGW("Invalid value for touch.pressure.calibration: '%s'",
+                    pressureCalibrationString.string());
+        }
+    }
+
+    out.pressureSource = Calibration::PRESSURE_SOURCE_DEFAULT;
+    String8 pressureSourceString;
+    if (in.tryGetProperty(String8("touch.pressure.source"), pressureSourceString)) {
+        if (pressureSourceString == "pressure") {
+            out.pressureSource = Calibration::PRESSURE_SOURCE_PRESSURE;
+        } else if (pressureSourceString == "touch") {
+            out.pressureSource = Calibration::PRESSURE_SOURCE_TOUCH;
+        } else if (pressureSourceString != "default") {
+            LOGW("Invalid value for touch.pressure.source: '%s'",
+                    pressureSourceString.string());
+        }
+    }
+
+    out.havePressureScale = in.tryGetProperty(String8("touch.pressure.scale"),
+            out.pressureScale);
+
+    // Size
+    out.sizeCalibration = Calibration::SIZE_CALIBRATION_DEFAULT;
+    String8 sizeCalibrationString;
+    if (in.tryGetProperty(String8("touch.size.calibration"), sizeCalibrationString)) {
+        if (sizeCalibrationString == "none") {
+            out.sizeCalibration = Calibration::SIZE_CALIBRATION_NONE;
+        } else if (sizeCalibrationString == "normalized") {
+            out.sizeCalibration = Calibration::SIZE_CALIBRATION_NORMALIZED;
+        } else if (sizeCalibrationString != "default") {
+            LOGW("Invalid value for touch.size.calibration: '%s'",
+                    sizeCalibrationString.string());
+        }
+    }
+
+    // Orientation
+    out.orientationCalibration = Calibration::ORIENTATION_CALIBRATION_DEFAULT;
+    String8 orientationCalibrationString;
+    if (in.tryGetProperty(String8("touch.orientation.calibration"), orientationCalibrationString)) {
+        if (orientationCalibrationString == "none") {
+            out.orientationCalibration = Calibration::ORIENTATION_CALIBRATION_NONE;
+        } else if (orientationCalibrationString == "interpolated") {
+            out.orientationCalibration = Calibration::ORIENTATION_CALIBRATION_INTERPOLATED;
+        } else if (orientationCalibrationString != "default") {
+            LOGW("Invalid value for touch.orientation.calibration: '%s'",
+                    orientationCalibrationString.string());
+        }
+    }
+}
+
+void ActiveStylusInputMapper::resolveCalibration() {
+    // Pressure
+    switch (mCalibration.pressureSource) {
+    case Calibration::PRESSURE_SOURCE_DEFAULT:
+        if (mRawAxes.pressure.valid) {
+            mCalibration.pressureSource = Calibration::PRESSURE_SOURCE_PRESSURE;
+        } else if (mRawAxes.touchMajor.valid) {
+            mCalibration.pressureSource = Calibration::PRESSURE_SOURCE_TOUCH;
+        }
+        break;
+
+    case Calibration::PRESSURE_SOURCE_PRESSURE:
+        if (! mRawAxes.pressure.valid) {
+            LOGW("Calibration property touch.pressure.source is 'pressure' but "
+                    "the pressure axis is not available.");
+        }
+        break;
+
+    case Calibration::PRESSURE_SOURCE_TOUCH:
+        if (! mRawAxes.touchMajor.valid) {
+            LOGW("Calibration property touch.pressure.source is 'touch' but "
+                    "the touchMajor axis is not available.");
+        }
+        break;
+
+    default:
+        break;
+    }
+
+    switch (mCalibration.pressureCalibration) {
+    case Calibration::PRESSURE_CALIBRATION_DEFAULT:
+        if (mCalibration.pressureSource != Calibration::PRESSURE_SOURCE_DEFAULT) {
+            mCalibration.pressureCalibration = Calibration::PRESSURE_CALIBRATION_AMPLITUDE;
+        } else {
+            mCalibration.pressureCalibration = Calibration::PRESSURE_CALIBRATION_NONE;
+        }
+        break;
+
+    default:
+        break;
+    }
+
+    // Tool Size
+    switch (mCalibration.toolSizeCalibration) {
+    case Calibration::TOOL_SIZE_CALIBRATION_DEFAULT:
+        if (mRawAxes.toolMajor.valid) {
+            mCalibration.toolSizeCalibration = Calibration::TOOL_SIZE_CALIBRATION_LINEAR;
+        } else {
+            mCalibration.toolSizeCalibration = Calibration::TOOL_SIZE_CALIBRATION_NONE;
+        }
+        break;
+
+    default:
+        break;
+    }
+
+    // Touch Size
+    switch (mCalibration.touchSizeCalibration) {
+    case Calibration::TOUCH_SIZE_CALIBRATION_DEFAULT:
+        if (mCalibration.pressureCalibration != Calibration::PRESSURE_CALIBRATION_NONE
+                && mCalibration.toolSizeCalibration != Calibration::TOOL_SIZE_CALIBRATION_NONE) {
+            mCalibration.touchSizeCalibration = Calibration::TOUCH_SIZE_CALIBRATION_PRESSURE;
+        } else {
+            mCalibration.touchSizeCalibration = Calibration::TOUCH_SIZE_CALIBRATION_NONE;
+        }
+        break;
+
+    default:
+        break;
+    }
+
+    // Size
+    switch (mCalibration.sizeCalibration) {
+    case Calibration::SIZE_CALIBRATION_DEFAULT:
+        if (mRawAxes.toolMajor.valid) {
+            mCalibration.sizeCalibration = Calibration::SIZE_CALIBRATION_NORMALIZED;
+        } else {
+            mCalibration.sizeCalibration = Calibration::SIZE_CALIBRATION_NONE;
+        }
+        break;
+
+    default:
+        break;
+    }
+
+    // Orientation
+    switch (mCalibration.orientationCalibration) {
+    case Calibration::ORIENTATION_CALIBRATION_DEFAULT:
+        if (mRawAxes.orientation.valid) {
+            mCalibration.orientationCalibration = Calibration::ORIENTATION_CALIBRATION_INTERPOLATED;
+        } else {
+            mCalibration.orientationCalibration = Calibration::ORIENTATION_CALIBRATION_NONE;
+        }
+        break;
+
+    default:
+        break;
+    }
+}
+
+void ActiveStylusInputMapper::dumpCalibration(String8& dump) {
+    dump.append(INDENT3 "Calibration:\n");
+
+    // Touch Size
+    switch (mCalibration.touchSizeCalibration) {
+    case Calibration::TOUCH_SIZE_CALIBRATION_NONE:
+        dump.append(INDENT4 "touch.touchSize.calibration: none\n");
+        break;
+    case Calibration::TOUCH_SIZE_CALIBRATION_GEOMETRIC:
+        dump.append(INDENT4 "touch.touchSize.calibration: geometric\n");
+        break;
+    case Calibration::TOUCH_SIZE_CALIBRATION_PRESSURE:
+        dump.append(INDENT4 "touch.touchSize.calibration: pressure\n");
+        break;
+    default:
+        assert(false);
+    }
+
+    // Tool Size
+    switch (mCalibration.toolSizeCalibration) {
+    case Calibration::TOOL_SIZE_CALIBRATION_NONE:
+        dump.append(INDENT4 "touch.toolSize.calibration: none\n");
+        break;
+    case Calibration::TOOL_SIZE_CALIBRATION_GEOMETRIC:
+        dump.append(INDENT4 "touch.toolSize.calibration: geometric\n");
+        break;
+    case Calibration::TOOL_SIZE_CALIBRATION_LINEAR:
+        dump.append(INDENT4 "touch.toolSize.calibration: linear\n");
+        break;
+    case Calibration::TOOL_SIZE_CALIBRATION_AREA:
+        dump.append(INDENT4 "touch.toolSize.calibration: area\n");
+        break;
+    default:
+        assert(false);
+    }
+
+    if (mCalibration.haveToolSizeLinearScale) {
+        dump.appendFormat(INDENT4 "touch.toolSize.linearScale: %0.3f\n",
+                mCalibration.toolSizeLinearScale);
+    }
+
+    if (mCalibration.haveToolSizeLinearBias) {
+        dump.appendFormat(INDENT4 "touch.toolSize.linearBias: %0.3f\n",
+                mCalibration.toolSizeLinearBias);
+    }
+
+    if (mCalibration.haveToolSizeAreaScale) {
+        dump.appendFormat(INDENT4 "touch.toolSize.areaScale: %0.3f\n",
+                mCalibration.toolSizeAreaScale);
+    }
+
+    if (mCalibration.haveToolSizeAreaBias) {
+        dump.appendFormat(INDENT4 "touch.toolSize.areaBias: %0.3f\n",
+                mCalibration.toolSizeAreaBias);
+    }
+
+    if (mCalibration.haveToolSizeIsSummed) {
+        dump.appendFormat(INDENT4 "touch.toolSize.isSummed: %d\n",
+                mCalibration.toolSizeIsSummed);
+    }
+
+    // Pressure
+    switch (mCalibration.pressureCalibration) {
+    case Calibration::PRESSURE_CALIBRATION_NONE:
+        dump.append(INDENT4 "touch.pressure.calibration: none\n");
+        break;
+    case Calibration::PRESSURE_CALIBRATION_PHYSICAL:
+        dump.append(INDENT4 "touch.pressure.calibration: physical\n");
+        break;
+    case Calibration::PRESSURE_CALIBRATION_AMPLITUDE:
+        dump.append(INDENT4 "touch.pressure.calibration: amplitude\n");
+        break;
+    default:
+        assert(false);
+    }
+
+    switch (mCalibration.pressureSource) {
+    case Calibration::PRESSURE_SOURCE_PRESSURE:
+        dump.append(INDENT4 "touch.pressure.source: pressure\n");
+        break;
+    case Calibration::PRESSURE_SOURCE_TOUCH:
+        dump.append(INDENT4 "touch.pressure.source: touch\n");
+        break;
+    case Calibration::PRESSURE_SOURCE_DEFAULT:
+        break;
+    default:
+        assert(false);
+    }
+
+    if (mCalibration.havePressureScale) {
+        dump.appendFormat(INDENT4 "touch.pressure.scale: %0.3f\n",
+                mCalibration.pressureScale);
+    }
+
+    // Size
+    switch (mCalibration.sizeCalibration) {
+    case Calibration::SIZE_CALIBRATION_NONE:
+        dump.append(INDENT4 "touch.size.calibration: none\n");
+        break;
+    case Calibration::SIZE_CALIBRATION_NORMALIZED:
+        dump.append(INDENT4 "touch.size.calibration: normalized\n");
+        break;
+    default:
+        assert(false);
+    }
+
+    // Orientation
+    switch (mCalibration.orientationCalibration) {
+    case Calibration::ORIENTATION_CALIBRATION_NONE:
+        dump.append(INDENT4 "touch.orientation.calibration: none\n");
+        break;
+    case Calibration::ORIENTATION_CALIBRATION_INTERPOLATED:
+        dump.append(INDENT4 "touch.orientation.calibration: interpolated\n");
+        break;
+    default:
+        assert(false);
+    }
+}
+
+void ActiveStylusInputMapper::reset() {
+    // Synthesize touch up event if touch is currently down.
+    // This will also take care of finishing virtual key processing if needed.
+    if (mLastTouch.pointerCount != 0) {
+        nsecs_t when = systemTime(SYSTEM_TIME_MONOTONIC);
+        mCurrentTouch.clear();
+        syncTouch(when, true);
+    }
+
+    { // acquire lock
+        AutoMutex _l(mLock);
+        initializeLocked();
+    } // release lock
+
+    InputMapper::reset();
+}
+
+void ActiveStylusInputMapper::syncTouch(nsecs_t when, bool havePointerIds) {
+    uint32_t policyFlags = 0;
+
+    // Preprocess pointer data.
+
+    /*if (mParameters.useBadTouchFilter) {
+        if (applyBadTouchFilter()) {
+            havePointerIds = false;
+        }
+    }
+
+    if (mParameters.useJumpyTouchFilter) {
+        if (applyJumpyTouchFilter()) {
+            havePointerIds = false;
+        }
+    }*/
+
+    if (! havePointerIds) {
+        calculatePointerIds();
+    }
+
+    TouchData temp;
+    TouchData* savedTouch;
+    /*if (mParameters.useAveragingTouchFilter) {
+        temp.copyFrom(mCurrentTouch);
+        savedTouch = & temp;
+
+        applyAveragingTouchFilter();
+    } else {*/
+        savedTouch = & mCurrentTouch;
+    //}
+
+    // Process touches and virtual keys.
+
+    TouchResult touchResult = consumeOffScreenTouches(when, policyFlags);
+    if (touchResult == DISPATCH_TOUCH) {
+        dispatchTouches(when, policyFlags);
+    }
+
+    // Copy current touch to last touch in preparation for the next cycle.
+
+    if (touchResult == DROP_STROKE) {
+        mLastTouch.clear();
+    } else {
+        mLastTouch.copyFrom(*savedTouch);
+    }
+}
+
+ActiveStylusInputMapper::TouchResult ActiveStylusInputMapper::consumeOffScreenTouches(
+        nsecs_t when, uint32_t policyFlags) {
+    int32_t keyEventAction, keyEventFlags;
+    int32_t keyCode, scanCode, downTime;
+    TouchResult touchResult;
+
+    { // acquire lock
+        AutoMutex _l(mLock);
+
+        // Update surface size and orientation, including virtual key positions.
+        if (! configureSurfaceLocked()) {
+            return DROP_STROKE;
+        }
+
+        // Check for virtual key press.
+        if (mLocked.currentVirtualKey.down) {
+            if (mCurrentTouch.pointerCount == 0) {
+                // Pointer went up while virtual key was down.
+                mLocked.currentVirtualKey.down = false;
+#if DEBUG_VIRTUAL_KEYS
+                LOGD("VirtualKeys: Generating key up: keyCode=%d, scanCode=%d",
+                        mLocked.currentVirtualKey.keyCode, mLocked.currentVirtualKey.scanCode);
+#endif
+                keyEventAction = AKEY_EVENT_ACTION_UP;
+                keyEventFlags = AKEY_EVENT_FLAG_FROM_SYSTEM | AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY;
+                touchResult = SKIP_TOUCH;
+                goto DispatchVirtualKey;
+            }
+
+            if (mCurrentTouch.pointerCount == 1) {
+                int32_t x = mCurrentTouch.pointers[0].x;
+                int32_t y = mCurrentTouch.pointers[0].y;
+                const VirtualKey* virtualKey = findVirtualKeyHitLocked(x, y);
+                if (virtualKey && virtualKey->keyCode == mLocked.currentVirtualKey.keyCode) {
+                    // Pointer is still within the space of the virtual key.
+                    return SKIP_TOUCH;
+                }
+            }
+
+            // Pointer left virtual key area or another pointer also went down.
+            // Send key cancellation and drop the stroke so subsequent motions will be
+            // considered fresh downs.  This is useful when the user swipes away from the
+            // virtual key area into the main display surface.
+            mLocked.currentVirtualKey.down = false;
+#if DEBUG_VIRTUAL_KEYS
+            LOGD("VirtualKeys: Canceling key: keyCode=%d, scanCode=%d",
+                    mLocked.currentVirtualKey.keyCode, mLocked.currentVirtualKey.scanCode);
+#endif
+            keyEventAction = AKEY_EVENT_ACTION_UP;
+            keyEventFlags = AKEY_EVENT_FLAG_FROM_SYSTEM | AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY
+                    | AKEY_EVENT_FLAG_CANCELED;
+
+            // Check whether the pointer moved inside the display area where we should
+            // start a new stroke.
+            int32_t x = mCurrentTouch.pointers[0].x;
+            int32_t y = mCurrentTouch.pointers[0].y;
+            if (isPointInsideSurfaceLocked(x, y)) {
+                mLastTouch.clear();
+                touchResult = DISPATCH_TOUCH;
+            } else {
+                touchResult = DROP_STROKE;
+            }
+        } else {
+            if (mCurrentTouch.pointerCount >= 1 && mLastTouch.pointerCount == 0) {
+                // Pointer just went down.  Handle off-screen touches, if needed.
+                int32_t x = mCurrentTouch.pointers[0].x;
+                int32_t y = mCurrentTouch.pointers[0].y;
+                if (! isPointInsideSurfaceLocked(x, y)) {
+                    // If exactly one pointer went down, check for virtual key hit.
+                    // Otherwise we will drop the entire stroke.
+                    if (mCurrentTouch.pointerCount == 1) {
+                        const VirtualKey* virtualKey = findVirtualKeyHitLocked(x, y);
+                        if (virtualKey) {
+                            mLocked.currentVirtualKey.down = true;
+                            mLocked.currentVirtualKey.downTime = when;
+                            mLocked.currentVirtualKey.keyCode = virtualKey->keyCode;
+                            mLocked.currentVirtualKey.scanCode = virtualKey->scanCode;
+#if DEBUG_VIRTUAL_KEYS
+                            LOGD("VirtualKeys: Generating key down: keyCode=%d, scanCode=%d",
+                                    mLocked.currentVirtualKey.keyCode,
+                                    mLocked.currentVirtualKey.scanCode);
+#endif
+                            keyEventAction = AKEY_EVENT_ACTION_DOWN;
+                            keyEventFlags = AKEY_EVENT_FLAG_FROM_SYSTEM
+                                    | AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY;
+                            touchResult = SKIP_TOUCH;
+                            goto DispatchVirtualKey;
+                        }
+                    }
+                    return DROP_STROKE;
+                }
+            }
+            return DISPATCH_TOUCH;
+        }
+
+    DispatchVirtualKey:
+        // Collect remaining state needed to dispatch virtual key.
+        keyCode = mLocked.currentVirtualKey.keyCode;
+        scanCode = mLocked.currentVirtualKey.scanCode;
+        downTime = mLocked.currentVirtualKey.downTime;
+    } // release lock
+
+    // Dispatch virtual key.
+    int32_t metaState = mContext->getGlobalMetaState();
+    policyFlags |= POLICY_FLAG_VIRTUAL;
+    getDispatcher()->notifyKey(when, getDeviceId(), AINPUT_SOURCE_KEYBOARD, policyFlags,
+            keyEventAction, keyEventFlags, keyCode, scanCode, metaState, downTime);
+    return touchResult;
+}
+
+/*void ActiveStylusInputMapper::dispatchTouches(nsecs_t when, uint32_t policyFlags) {
+    uint32_t currentPointerCount = mCurrentTouch.pointerCount;
+    uint32_t lastPointerCount = mLastTouch.pointerCount;
+    if (currentPointerCount == 0 && lastPointerCount == 0) {
+        return; // nothing to do!
+    }
+
+    BitSet32 currentIdBits = mCurrentTouch.idBits;
+    BitSet32 lastIdBits = mLastTouch.idBits;
+
+    if (currentIdBits == lastIdBits) {
+        // No pointer id changes so this is a move event.
+        // The dispatcher takes care of batching moves so we don't have to deal with that here.
+        int32_t motionEventAction = AMOTION_EVENT_ACTION_MOVE;
+        dispatchTouch(when, policyFlags, & mCurrentTouch,
+                currentIdBits, -1, currentPointerCount, motionEventAction);
+    } else {
+        // There may be pointers going up and pointers going down and pointers moving
+        // all at the same time.
+        BitSet32 upIdBits(lastIdBits.value & ~ currentIdBits.value);
+        BitSet32 downIdBits(currentIdBits.value & ~ lastIdBits.value);
+        BitSet32 activeIdBits(lastIdBits.value);
+        uint32_t pointerCount = lastPointerCount;
+
+        // Produce an intermediate representation of the touch data that consists of the
+        // old location of pointers that have just gone up and the new location of pointers that
+        // have just moved but omits the location of pointers that have just gone down.
+        TouchData interimTouch;
+        interimTouch.copyFrom(mLastTouch);
+
+        BitSet32 moveIdBits(lastIdBits.value & currentIdBits.value);
+        bool moveNeeded = false;
+        while (!moveIdBits.isEmpty()) {
+            uint32_t moveId = moveIdBits.firstMarkedBit();
+            moveIdBits.clearBit(moveId);
+
+            int32_t oldIndex = mLastTouch.idToIndex[moveId];
+            int32_t newIndex = mCurrentTouch.idToIndex[moveId];
+            if (mLastTouch.pointers[oldIndex] != mCurrentTouch.pointers[newIndex]) {
+                interimTouch.pointers[oldIndex] = mCurrentTouch.pointers[newIndex];
+                moveNeeded = true;
+            }
+        }
+
+        // Dispatch pointer up events using the interim pointer locations.
+        while (!upIdBits.isEmpty()) {
+            uint32_t upId = upIdBits.firstMarkedBit();
+            upIdBits.clearBit(upId);
+            BitSet32 oldActiveIdBits = activeIdBits;
+            activeIdBits.clearBit(upId);
+
+            int32_t motionEventAction;
+            if (activeIdBits.isEmpty()) {
+                motionEventAction = AMOTION_EVENT_ACTION_UP;
+            } else {
+                motionEventAction = AMOTION_EVENT_ACTION_POINTER_UP;
+            }
+
+            dispatchTouch(when, policyFlags, &interimTouch,
+                    oldActiveIdBits, upId, pointerCount, motionEventAction);
+            pointerCount -= 1;
+        }
+
+        // Dispatch move events if any of the remaining pointers moved from their old locations.
+        // Although applications receive new locations as part of individual pointer up
+        // events, they do not generally handle them except when presented in a move event.
+        if (moveNeeded) {
+            dispatchTouch(when, policyFlags, &mCurrentTouch,
+                    activeIdBits, -1, pointerCount, AMOTION_EVENT_ACTION_MOVE);
+        }
+
+        // Dispatch pointer down events using the new pointer locations.
+        while (!downIdBits.isEmpty()) {
+            uint32_t downId = downIdBits.firstMarkedBit();
+            downIdBits.clearBit(downId);
+            BitSet32 oldActiveIdBits = activeIdBits;
+            activeIdBits.markBit(downId);
+
+            int32_t motionEventAction;
+            if (oldActiveIdBits.isEmpty()) {
+                motionEventAction = AMOTION_EVENT_ACTION_DOWN;
+                mDownTime = when;
+            } else {
+                motionEventAction = AMOTION_EVENT_ACTION_POINTER_DOWN;
+            }
+
+            pointerCount += 1;
+            dispatchTouch(when, policyFlags, &mCurrentTouch,
+                    activeIdBits, downId, pointerCount, motionEventAction);
+        }
+    }
+}*/
+
+void ActiveStylusInputMapper::dispatchTouches(nsecs_t when, uint32_t policyFlags) {
+    uint32_t currentPointerCount = mCurrentTouch.pointerCount;
+    uint32_t lastPointerCount = mLastTouch.pointerCount;
+    if (currentPointerCount == 0 && lastPointerCount == 0) {
+        return; // nothing to do!
+    }
+    
+    BitSet32 currentIdBits = mCurrentTouch.idBits;
+    BitSet32 lastIdBits = mLastTouch.idBits;
+
+    if (currentPointerCount == 0 && lastPointerCount == 1) {
+        // Pointer exiting proximity
+        TouchData interimTouch;
+        interimTouch.copyFrom(mLastTouch);
+
+        interimTouch.idBits.markBit(0);
+        // TODO: figure out a better way to do this
+        //interimTouch.pointers[0].buttonStylus = false;
+        //interimTouch.pointers[0].buttonStylus2 = false;
+
+        dispatchTouch(when, policyFlags, & interimTouch,
+                interimTouch.idBits, -1, 1, AMOTION_EVENT_ACTION_EXIT_PROXIMITY);
+    } else if (currentPointerCount == 1 && lastPointerCount == 0) {
+        // Pointer entering proximity
+        TouchData interimTouch;
+        interimTouch.copyFrom(mCurrentTouch);
+
+        interimTouch.idBits.markBit(0);
+
+        dispatchTouch(when, policyFlags, & interimTouch,
+                interimTouch.idBits, -1, 1, AMOTION_EVENT_ACTION_ENTER_PROXIMITY);
+    }
+
+    if (currentPointerCount != 0) {
+        if (currentIdBits == lastIdBits) {
+            int32_t motionEventAction = (currentIdBits.value > 0) ? 
+                AMOTION_EVENT_ACTION_MOVE : AMOTION_EVENT_ACTION_HOVER;
+            currentIdBits.markBit(0);
+            dispatchTouch(when, policyFlags, & mCurrentTouch,
+                    currentIdBits, -1, currentPointerCount, motionEventAction);
+        } else if (currentIdBits.value > lastIdBits.value) {
+            dispatchTouch(when, policyFlags, & mCurrentTouch,
+                    currentIdBits, 0, currentPointerCount, AMOTION_EVENT_ACTION_DOWN);
+        } else if (currentIdBits.value < lastIdBits.value) {
+            dispatchTouch(when, policyFlags, & mCurrentTouch,
+                    lastIdBits, 0, currentPointerCount, AMOTION_EVENT_ACTION_UP);
+        }
+    }
+
+    /*if (currentIdBits == lastIdBits) {
+        // No pointer id changes so this is a move event.
+        // The dispatcher takes care of batching moves so we don't have to deal with that here.
+        int32_t motionEventAction = AMOTION_EVENT_ACTION_MOVE;
+        dispatchTouch(when, policyFlags, & mCurrentTouch,
+                currentIdBits, -1, currentPointerCount, motionEventAction);
+    } else {
+        // There may be pointers going up and pointers going down and pointers moving
+        // all at the same time.
+        BitSet32 upIdBits(lastIdBits.value & ~ currentIdBits.value);
+        BitSet32 downIdBits(currentIdBits.value & ~ lastIdBits.value);
+        BitSet32 activeIdBits(lastIdBits.value);
+        uint32_t pointerCount = lastPointerCount;
+
+        // Produce an intermediate representation of the touch data that consists of the
+        // old location of pointers that have just gone up and the new location of pointers that
+        // have just moved but omits the location of pointers that have just gone down.
+        TouchData interimTouch;
+        interimTouch.copyFrom(mLastTouch);
+
+        BitSet32 moveIdBits(lastIdBits.value & currentIdBits.value);
+        bool moveNeeded = false;
+        while (!moveIdBits.isEmpty()) {
+            uint32_t moveId = moveIdBits.firstMarkedBit();
+            moveIdBits.clearBit(moveId);
+
+            int32_t oldIndex = mLastTouch.idToIndex[moveId];
+            int32_t newIndex = mCurrentTouch.idToIndex[moveId];
+            if (mLastTouch.pointers[oldIndex] != mCurrentTouch.pointers[newIndex]) {
+                interimTouch.pointers[oldIndex] = mCurrentTouch.pointers[newIndex];
+                moveNeeded = true;
+            }
+        }
+
+        // Dispatch pointer up events using the interim pointer locations.
+        while (!upIdBits.isEmpty()) {
+            uint32_t upId = upIdBits.firstMarkedBit();
+            upIdBits.clearBit(upId);
+            BitSet32 oldActiveIdBits = activeIdBits;
+            activeIdBits.clearBit(upId);
+
+            int32_t motionEventAction;
+            if (activeIdBits.isEmpty()) {
+                motionEventAction = AMOTION_EVENT_ACTION_UP;
+            } else {
+                motionEventAction = AMOTION_EVENT_ACTION_POINTER_UP;
+            }
+
+            dispatchTouch(when, policyFlags, &interimTouch,
+                    oldActiveIdBits, upId, pointerCount, motionEventAction);
+            pointerCount -= 1;
+        }
+
+        // Dispatch move events if any of the remaining pointers moved from their old locations.
+        // Although applications receive new locations as part of individual pointer up
+        // events, they do not generally handle them except when presented in a move event.
+        if (moveNeeded) {
+            dispatchTouch(when, policyFlags, &mCurrentTouch,
+                    activeIdBits, -1, pointerCount, AMOTION_EVENT_ACTION_MOVE);
+        }
+
+        // Dispatch pointer down events using the new pointer locations.
+        while (!downIdBits.isEmpty()) {
+            uint32_t downId = downIdBits.firstMarkedBit();
+            downIdBits.clearBit(downId);
+            BitSet32 oldActiveIdBits = activeIdBits;
+            activeIdBits.markBit(downId);
+
+            int32_t motionEventAction;
+            if (oldActiveIdBits.isEmpty()) {
+                motionEventAction = AMOTION_EVENT_ACTION_DOWN;
+                mDownTime = when;
+            } else {
+                motionEventAction = AMOTION_EVENT_ACTION_POINTER_DOWN;
+            }
+
+            pointerCount += 1;
+            dispatchTouch(when, policyFlags, &mCurrentTouch,
+                    activeIdBits, downId, pointerCount, motionEventAction);
+        }
+    }*/
+}
+
+void ActiveStylusInputMapper::dispatchTouch(nsecs_t when, uint32_t policyFlags,
+        TouchData* touch, BitSet32 idBits, uint32_t changedId, uint32_t pointerCount,
+        int32_t motionEventAction) {
+    int32_t pointerIds[MAX_POINTERS];
+    PointerCoords pointerCoords[MAX_POINTERS];
+    int32_t motionEventEdgeFlags = 0;
+    float xPrecision, yPrecision;
+    int32_t newMetaState;
+    bool metaStateChanged = false;
+    int32_t toolType;
+
+    { // acquire lock
+        AutoMutex _l(mLock);
+
+        // Walk through the the active pointers and map touch screen coordinates (TouchData) into
+        // display coordinates (PointerCoords) and adjust for display orientation.
+        for (uint32_t outIndex = 0; ! idBits.isEmpty(); outIndex++) {
+            uint32_t id = idBits.firstMarkedBit();
+            idBits.clearBit(id);
+            uint32_t inIndex = touch->idToIndex[id];
+
+            const PointerData& in = touch->pointers[inIndex];
+
+            // X and Y
+            float x = float(in.x - mLocked.xOrigin) * mLocked.xScale;
+            float y = float(in.y - mLocked.yOrigin) * mLocked.yScale;
+
+            // ToolMajor and ToolMinor
+            float toolMajor, toolMinor;
+            switch (mCalibration.toolSizeCalibration) {
+            case Calibration::TOOL_SIZE_CALIBRATION_GEOMETRIC:
+                toolMajor = in.toolMajor * mLocked.geometricScale;
+                if (mRawAxes.toolMinor.valid) {
+                    toolMinor = in.toolMinor * mLocked.geometricScale;
+                } else {
+                    toolMinor = toolMajor;
+                }
+                break;
+            case Calibration::TOOL_SIZE_CALIBRATION_LINEAR:
+                toolMajor = in.toolMajor != 0
+                        ? in.toolMajor * mLocked.toolSizeLinearScale + mLocked.toolSizeLinearBias
+                        : 0;
+                if (mRawAxes.toolMinor.valid) {
+                    toolMinor = in.toolMinor != 0
+                            ? in.toolMinor * mLocked.toolSizeLinearScale
+                                    + mLocked.toolSizeLinearBias
+                            : 0;
+                } else {
+                    toolMinor = toolMajor;
+                }
+                break;
+            case Calibration::TOOL_SIZE_CALIBRATION_AREA:
+                if (in.toolMajor != 0) {
+                    float diameter = sqrtf(in.toolMajor
+                            * mLocked.toolSizeAreaScale + mLocked.toolSizeAreaBias);
+                    toolMajor = diameter * mLocked.toolSizeLinearScale + mLocked.toolSizeLinearBias;
+                } else {
+                    toolMajor = 0;
+                }
+                toolMinor = toolMajor;
+                break;
+            default:
+                toolMajor = 0;
+                toolMinor = 0;
+                break;
+            }
+
+            if (mCalibration.haveToolSizeIsSummed && mCalibration.toolSizeIsSummed) {
+                toolMajor /= pointerCount;
+                toolMinor /= pointerCount;
+            }
+
+            // Pressure
+            float rawPressure;
+            switch (mCalibration.pressureSource) {
+            case Calibration::PRESSURE_SOURCE_PRESSURE:
+                rawPressure = in.pressure;
+                break;
+            case Calibration::PRESSURE_SOURCE_TOUCH:
+                rawPressure = in.touchMajor;
+                break;
+            default:
+                rawPressure = 0;
+            }
+
+            float pressure;
+            switch (mCalibration.pressureCalibration) {
+            case Calibration::PRESSURE_CALIBRATION_PHYSICAL:
+            case Calibration::PRESSURE_CALIBRATION_AMPLITUDE:
+                pressure = rawPressure * mLocked.pressureScale;
+                break;
+            default:
+                pressure = 1;
+                break;
+            }
+
+            // TouchMajor and TouchMinor
+            float touchMajor, touchMinor;
+            switch (mCalibration.touchSizeCalibration) {
+            case Calibration::TOUCH_SIZE_CALIBRATION_GEOMETRIC:
+                touchMajor = in.touchMajor * mLocked.geometricScale;
+                if (mRawAxes.touchMinor.valid) {
+                    touchMinor = in.touchMinor * mLocked.geometricScale;
+                } else {
+                    touchMinor = touchMajor;
+                }
+                break;
+            case Calibration::TOUCH_SIZE_CALIBRATION_PRESSURE:
+                touchMajor = toolMajor * pressure;
+                touchMinor = toolMinor * pressure;
+                break;
+            default:
+                touchMajor = 0;
+                touchMinor = 0;
+                break;
+            }
+
+            if (touchMajor > toolMajor) {
+                touchMajor = toolMajor;
+            }
+            if (touchMinor > toolMinor) {
+                touchMinor = toolMinor;
+            }
+
+            // Size
+            float size;
+            switch (mCalibration.sizeCalibration) {
+            case Calibration::SIZE_CALIBRATION_NORMALIZED: {
+                float rawSize = mRawAxes.toolMinor.valid
+                        ? avg(in.toolMajor, in.toolMinor)
+                        : in.toolMajor;
+                size = rawSize * mLocked.sizeScale;
+                break;
+            }
+            default:
+                size = 0;
+                break;
+            }
+
+            // Orientation
+            float orientation;
+            switch (mCalibration.orientationCalibration) {
+            case Calibration::ORIENTATION_CALIBRATION_INTERPOLATED:
+                orientation = in.orientation * mLocked.orientationScale;
+                break;
+            default:
+                orientation = 0;
+            }
+
+            // Adjust coords for orientation.
+            switch (mLocked.surfaceOrientation) {
+            case InputReaderPolicyInterface::ROTATION_90: {
+                float xTemp = x;
+                x = y;
+                y = mLocked.surfaceWidth - xTemp;
+                orientation -= M_PI_2;
+                if (orientation < - M_PI_2) {
+                    orientation += M_PI;
+                }
+                break;
+            }
+            case InputReaderPolicyInterface::ROTATION_180: {
+                x = mLocked.surfaceWidth - x;
+                y = mLocked.surfaceHeight - y;
+                orientation = - orientation;
+                break;
+            }
+            case InputReaderPolicyInterface::ROTATION_270: {
+                float xTemp = x;
+                x = mLocked.surfaceHeight - y;
+                y = xTemp;
+                orientation += M_PI_2;
+                if (orientation > M_PI_2) {
+                    orientation -= M_PI;
+                }
+                break;
+            }
+            }
+
+            // Write output coords.
+            PointerCoords& out = pointerCoords[outIndex];
+            out.x = x;
+            out.y = y;
+            out.pressure = pressure;
+            out.size = size;
+            out.touchMajor = touchMajor;
+            out.touchMinor = touchMinor;
+            out.toolMajor = toolMajor;
+            out.toolMinor = toolMinor;
+            out.orientation = orientation;
+
+            pointerIds[outIndex] = int32_t(id);
+
+            LOGD("outIndex: %d id: %d changedId: %d", outIndex, id, changedId);
+
+            if (id == changedId) {
+                motionEventAction |= outIndex << AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;
+            }
+        }
+
+        // Check edge flags by looking only at the first pointer since the flags are
+        // global to the event.
+        if (motionEventAction == AMOTION_EVENT_ACTION_DOWN) {
+            if (pointerCoords[0].x <= 0) {
+                motionEventEdgeFlags |= AMOTION_EVENT_EDGE_FLAG_LEFT;
+            } else if (pointerCoords[0].x >= mLocked.orientedSurfaceWidth) {
+                motionEventEdgeFlags |= AMOTION_EVENT_EDGE_FLAG_RIGHT;
+            }
+            if (pointerCoords[0].y <= 0) {
+                motionEventEdgeFlags |= AMOTION_EVENT_EDGE_FLAG_TOP;
+            } else if (pointerCoords[0].y >= mLocked.orientedSurfaceHeight) {
+                motionEventEdgeFlags |= AMOTION_EVENT_EDGE_FLAG_BOTTOM;
+            }
+        }
+
+        xPrecision = mLocked.orientedXPrecision;
+        yPrecision = mLocked.orientedYPrecision;
+
+        // Determine meta state
+        int32_t oldMetaState = mLocked.metaState;
+        newMetaState = updateMetaState(AKEYCODE_BUTTON_STYLUS, touch->pointers[0].buttonStylus, oldMetaState);
+        newMetaState = updateMetaState(AKEYCODE_BUTTON_STYLUS2, touch->pointers[0].buttonStylus2, newMetaState);
+        if (oldMetaState != newMetaState) {
+            mLocked.metaState = newMetaState;
+            metaStateChanged = true;
+        }
+
+        // Determine tool type
+        toolType = touch->pointers[0].toolType;
+    } // release lock
+    
+    if (metaStateChanged) {
+        getContext()->updateGlobalMetaState();
+    }
+
+
+    LOGD("action: %d pointerCount: %d downTime: %ld", motionEventAction, pointerCount, mDownTime);
+    
+    getDispatcher()->notifyMotion(when, getDeviceId(), getSources(), policyFlags,
+            motionEventAction, toolType, 0, newMetaState, motionEventEdgeFlags,
+            pointerCount, pointerIds, pointerCoords,
+            xPrecision, yPrecision, mDownTime);
+}
+
+bool ActiveStylusInputMapper::isPointInsideSurfaceLocked(int32_t x, int32_t y) {
+    if (mRawAxes.x.valid && mRawAxes.y.valid) {
+        return x >= mRawAxes.x.minValue && x <= mRawAxes.x.maxValue
+                && y >= mRawAxes.y.minValue && y <= mRawAxes.y.maxValue;
+    }
+    return true;
+}
+
+const ActiveStylusInputMapper::VirtualKey* ActiveStylusInputMapper::findVirtualKeyHitLocked(
+        int32_t x, int32_t y) {
+    size_t numVirtualKeys = mLocked.virtualKeys.size();
+    for (size_t i = 0; i < numVirtualKeys; i++) {
+        const VirtualKey& virtualKey = mLocked.virtualKeys[i];
+
+#if DEBUG_VIRTUAL_KEYS
+        LOGD("VirtualKeys: Hit test (%d, %d): keyCode=%d, scanCode=%d, "
+                "left=%d, top=%d, right=%d, bottom=%d",
+                x, y,
+                virtualKey.keyCode, virtualKey.scanCode,
+                virtualKey.hitLeft, virtualKey.hitTop,
+                virtualKey.hitRight, virtualKey.hitBottom);
+#endif
+
+        if (virtualKey.isHit(x, y)) {
+            return & virtualKey;
+        }
+    }
+
+    return NULL;
+}
+
+void ActiveStylusInputMapper::calculatePointerIds() {
+    uint32_t currentPointerCount = mCurrentTouch.pointerCount;
+    uint32_t lastPointerCount = mLastTouch.pointerCount;
+
+    if (currentPointerCount == 0) {
+        // No pointers to assign.
+        mCurrentTouch.idBits.clear();
+    } else if (lastPointerCount == 0) {
+        // All pointers are new.
+        mCurrentTouch.idBits.clear();
+        for (uint32_t i = 0; i < currentPointerCount; i++) {
+            mCurrentTouch.pointers[i].id = i;
+            mCurrentTouch.idToIndex[i] = i;
+            mCurrentTouch.idBits.markBit(i);
+        }
+    } else if (currentPointerCount == 1 && lastPointerCount == 1) {
+        // Only one pointer and no change in count so it must have the same id as before.
+        uint32_t id = mLastTouch.pointers[0].id;
+        mCurrentTouch.pointers[0].id = id;
+        mCurrentTouch.idToIndex[id] = 0;
+        mCurrentTouch.idBits.value = BitSet32::valueForBit(id);
+    } else {
+        // General case.
+        // We build a heap of squared euclidean distances between current and last pointers
+        // associated with the current and last pointer indices.  Then, we find the best
+        // match (by distance) for each current pointer.
+        PointerDistanceHeapElement heap[MAX_POINTERS * MAX_POINTERS];
+
+        uint32_t heapSize = 0;
+        for (uint32_t currentPointerIndex = 0; currentPointerIndex < currentPointerCount;
+                currentPointerIndex++) {
+            for (uint32_t lastPointerIndex = 0; lastPointerIndex < lastPointerCount;
+                    lastPointerIndex++) {
+                int64_t deltaX = mCurrentTouch.pointers[currentPointerIndex].x
+                        - mLastTouch.pointers[lastPointerIndex].x;
+                int64_t deltaY = mCurrentTouch.pointers[currentPointerIndex].y
+                        - mLastTouch.pointers[lastPointerIndex].y;
+
+                uint64_t distance = uint64_t(deltaX * deltaX + deltaY * deltaY);
+
+                // Insert new element into the heap (sift up).
+                heap[heapSize].currentPointerIndex = currentPointerIndex;
+                heap[heapSize].lastPointerIndex = lastPointerIndex;
+                heap[heapSize].distance = distance;
+                heapSize += 1;
+            }
+        }
+
+        // Heapify
+        for (uint32_t startIndex = heapSize / 2; startIndex != 0; ) {
+            startIndex -= 1;
+            for (uint32_t parentIndex = startIndex; ;) {
+                uint32_t childIndex = parentIndex * 2 + 1;
+                if (childIndex >= heapSize) {
+                    break;
+                }
+
+                if (childIndex + 1 < heapSize
+                        && heap[childIndex + 1].distance < heap[childIndex].distance) {
+                    childIndex += 1;
+                }
+
+                if (heap[parentIndex].distance <= heap[childIndex].distance) {
+                    break;
+                }
+
+                swap(heap[parentIndex], heap[childIndex]);
+                parentIndex = childIndex;
+            }
+        }
+
+#if DEBUG_POINTER_ASSIGNMENT
+        LOGD("calculatePointerIds - initial distance min-heap: size=%d", heapSize);
+        for (size_t i = 0; i < heapSize; i++) {
+            LOGD("  heap[%d]: cur=%d, last=%d, distance=%lld",
+                    i, heap[i].currentPointerIndex, heap[i].lastPointerIndex,
+                    heap[i].distance);
+        }
+#endif
+
+        // Pull matches out by increasing order of distance.
+        // To avoid reassigning pointers that have already been matched, the loop keeps track
+        // of which last and current pointers have been matched using the matchedXXXBits variables.
+        // It also tracks the used pointer id bits.
+        BitSet32 matchedLastBits(0);
+        BitSet32 matchedCurrentBits(0);
+        BitSet32 usedIdBits(0);
+        bool first = true;
+        for (uint32_t i = min(currentPointerCount, lastPointerCount); i > 0; i--) {
+            for (;;) {
+                if (first) {
+                    // The first time through the loop, we just consume the root element of
+                    // the heap (the one with smallest distance).
+                    first = false;
+                } else {
+                    // Previous iterations consumed the root element of the heap.
+                    // Pop root element off of the heap (sift down).
+                    heapSize -= 1;
+                    assert(heapSize > 0);
+
+                    // Sift down.
+                    heap[0] = heap[heapSize];
+                    for (uint32_t parentIndex = 0; ;) {
+                        uint32_t childIndex = parentIndex * 2 + 1;
+                        if (childIndex >= heapSize) {
+                            break;
+                        }
+
+                        if (childIndex + 1 < heapSize
+                                && heap[childIndex + 1].distance < heap[childIndex].distance) {
+                            childIndex += 1;
+                        }
+
+                        if (heap[parentIndex].distance <= heap[childIndex].distance) {
+                            break;
+                        }
+
+                        swap(heap[parentIndex], heap[childIndex]);
+                        parentIndex = childIndex;
+                    }
+
+#if DEBUG_POINTER_ASSIGNMENT
+                    LOGD("calculatePointerIds - reduced distance min-heap: size=%d", heapSize);
+                    for (size_t i = 0; i < heapSize; i++) {
+                        LOGD("  heap[%d]: cur=%d, last=%d, distance=%lld",
+                                i, heap[i].currentPointerIndex, heap[i].lastPointerIndex,
+                                heap[i].distance);
+                    }
+#endif
+                }
+
+                uint32_t currentPointerIndex = heap[0].currentPointerIndex;
+                if (matchedCurrentBits.hasBit(currentPointerIndex)) continue; // already matched
+
+                uint32_t lastPointerIndex = heap[0].lastPointerIndex;
+                if (matchedLastBits.hasBit(lastPointerIndex)) continue; // already matched
+
+                matchedCurrentBits.markBit(currentPointerIndex);
+                matchedLastBits.markBit(lastPointerIndex);
+
+                uint32_t id = mLastTouch.pointers[lastPointerIndex].id;
+                mCurrentTouch.pointers[currentPointerIndex].id = id;
+                mCurrentTouch.idToIndex[id] = currentPointerIndex;
+                usedIdBits.markBit(id);
+
+#if DEBUG_POINTER_ASSIGNMENT
+                LOGD("calculatePointerIds - matched: cur=%d, last=%d, id=%d, distance=%lld",
+                        lastPointerIndex, currentPointerIndex, id, heap[0].distance);
+#endif
+                break;
+            }
+        }
+
+        // Assign fresh ids to new pointers.
+        if (currentPointerCount > lastPointerCount) {
+            for (uint32_t i = currentPointerCount - lastPointerCount; ;) {
+                uint32_t currentPointerIndex = matchedCurrentBits.firstUnmarkedBit();
+                uint32_t id = usedIdBits.firstUnmarkedBit();
+
+                mCurrentTouch.pointers[currentPointerIndex].id = id;
+                mCurrentTouch.idToIndex[id] = currentPointerIndex;
+                usedIdBits.markBit(id);
+
+#if DEBUG_POINTER_ASSIGNMENT
+                LOGD("calculatePointerIds - assigned: cur=%d, id=%d",
+                        currentPointerIndex, id);
+#endif
+
+                if (--i == 0) break; // done
+                matchedCurrentBits.markBit(currentPointerIndex);
+            }
+        }
+
+        // Fix id bits.
+        mCurrentTouch.idBits = usedIdBits;
+    }
+}
+
+/* Special hack for devices that have bad screen data: if one of the
+ * points has moved more than a screen height from the last position,
+ * then drop it. */
+/*bool ActiveStylusInputMapper::applyBadTouchFilter() {
+    // This hack requires valid axis parameters.
+    if (! mRawAxes.y.valid) {
+        return false;
+    }
+
+    uint32_t pointerCount = mCurrentTouch.pointerCount;
+
+    // Nothing to do if there are no points.
+    if (pointerCount == 0) {
+        return false;
+    }
+
+    // Don't do anything if a finger is going down or up.  We run
+    // here before assigning pointer IDs, so there isn't a good
+    // way to do per-finger matching.
+    if (pointerCount != mLastTouch.pointerCount) {
+        return false;
+    }
+
+    // We consider a single movement across more than a 7/16 of
+    // the long size of the screen to be bad.  This was a magic value
+    // determined by looking at the maximum distance it is feasible
+    // to actually move in one sample.
+    int32_t maxDeltaY = mRawAxes.y.getRange() * 7 / 16;
+
+    // XXX The original code in InputDevice.java included commented out
+    //     code for testing the X axis.  Note that when we drop a point
+    //     we don't actually restore the old X either.  Strange.
+    //     The old code also tries to track when bad points were previously
+    //     detected but it turns out that due to the placement of a "break"
+    //     at the end of the loop, we never set mDroppedBadPoint to true
+    //     so it is effectively dead code.
+    // Need to figure out if the old code is busted or just overcomplicated
+    // but working as intended.
+
+    // Look through all new points and see if any are farther than
+    // acceptable from all previous points.
+    for (uint32_t i = pointerCount; i-- > 0; ) {
+        int32_t y = mCurrentTouch.pointers[i].y;
+        int32_t closestY = INT_MAX;
+        int32_t closestDeltaY = 0;
+
+#if DEBUG_HACKS
+        LOGD("BadTouchFilter: Looking at next point #%d: y=%d", i, y);
+#endif
+
+        for (uint32_t j = pointerCount; j-- > 0; ) {
+            int32_t lastY = mLastTouch.pointers[j].y;
+            int32_t deltaY = abs(y - lastY);
+
+#if DEBUG_HACKS
+            LOGD("BadTouchFilter: Comparing with last point #%d: y=%d deltaY=%d",
+                    j, lastY, deltaY);
+#endif
+
+            if (deltaY < maxDeltaY) {
+                goto SkipSufficientlyClosePoint;
+            }
+            if (deltaY < closestDeltaY) {
+                closestDeltaY = deltaY;
+                closestY = lastY;
+            }
+        }
+
+        // Must not have found a close enough match.
+#if DEBUG_HACKS
+        LOGD("BadTouchFilter: Dropping bad point #%d: newY=%d oldY=%d deltaY=%d maxDeltaY=%d",
+                i, y, closestY, closestDeltaY, maxDeltaY);
+#endif
+
+        mCurrentTouch.pointers[i].y = closestY;
+        return true; // XXX original code only corrects one point
+
+    SkipSufficientlyClosePoint: ;
+    }
+
+    // No change.
+    return false;
+}*/
+
+/* Special hack for devices that have bad screen data: drop points where
+ * the coordinate value for one axis has jumped to the other pointer's location.
+ */
+/*bool ActiveStylusInputMapper::applyJumpyTouchFilter() {
+    // This hack requires valid axis parameters.
+    if (! mRawAxes.y.valid) {
+        return false;
+    }
+
+    uint32_t pointerCount = mCurrentTouch.pointerCount;
+    if (mLastTouch.pointerCount != pointerCount) {
+#if DEBUG_HACKS
+        LOGD("JumpyTouchFilter: Different pointer count %d -> %d",
+                mLastTouch.pointerCount, pointerCount);
+        for (uint32_t i = 0; i < pointerCount; i++) {
+            LOGD("  Pointer %d (%d, %d)", i,
+                    mCurrentTouch.pointers[i].x, mCurrentTouch.pointers[i].y);
+        }
+#endif
+
+        if (mJumpyTouchFilter.jumpyPointsDropped < JUMPY_TRANSITION_DROPS) {
+            if (mLastTouch.pointerCount == 1 && pointerCount == 2) {
+                // Just drop the first few events going from 1 to 2 pointers.
+                // They're bad often enough that they're not worth considering.
+                mCurrentTouch.pointerCount = 1;
+                mJumpyTouchFilter.jumpyPointsDropped += 1;
+
+#if DEBUG_HACKS
+                LOGD("JumpyTouchFilter: Pointer 2 dropped");
+#endif
+                return true;
+            } else if (mLastTouch.pointerCount == 2 && pointerCount == 1) {
+                // The event when we go from 2 -> 1 tends to be messed up too
+                mCurrentTouch.pointerCount = 2;
+                mCurrentTouch.pointers[0] = mLastTouch.pointers[0];
+                mCurrentTouch.pointers[1] = mLastTouch.pointers[1];
+                mJumpyTouchFilter.jumpyPointsDropped += 1;
+
+#if DEBUG_HACKS
+                for (int32_t i = 0; i < 2; i++) {
+                    LOGD("JumpyTouchFilter: Pointer %d replaced (%d, %d)", i,
+                            mCurrentTouch.pointers[i].x, mCurrentTouch.pointers[i].y);
+                }
+#endif
+                return true;
+            }
+        }
+        // Reset jumpy points dropped on other transitions or if limit exceeded.
+        mJumpyTouchFilter.jumpyPointsDropped = 0;
+
+#if DEBUG_HACKS
+        LOGD("JumpyTouchFilter: Transition - drop limit reset");
+#endif
+        return false;
+    }
+
+    // We have the same number of pointers as last time.
+    // A 'jumpy' point is one where the coordinate value for one axis
+    // has jumped to the other pointer's location. No need to do anything
+    // else if we only have one pointer.
+    if (pointerCount < 2) {
+        return false;
+    }
+
+    if (mJumpyTouchFilter.jumpyPointsDropped < JUMPY_DROP_LIMIT) {
+        int jumpyEpsilon = mRawAxes.y.getRange() / JUMPY_EPSILON_DIVISOR;
+
+        // We only replace the single worst jumpy point as characterized by pointer distance
+        // in a single axis.
+        int32_t badPointerIndex = -1;
+        int32_t badPointerReplacementIndex = -1;
+        int32_t badPointerDistance = INT_MIN; // distance to be corrected
+
+        for (uint32_t i = pointerCount; i-- > 0; ) {
+            int32_t x = mCurrentTouch.pointers[i].x;
+            int32_t y = mCurrentTouch.pointers[i].y;
+
+#if DEBUG_HACKS
+            LOGD("JumpyTouchFilter: Point %d (%d, %d)", i, x, y);
+#endif
+
+            // Check if a touch point is too close to another's coordinates
+            bool dropX = false, dropY = false;
+            for (uint32_t j = 0; j < pointerCount; j++) {
+                if (i == j) {
+                    continue;
+                }
+
+                if (abs(x - mCurrentTouch.pointers[j].x) <= jumpyEpsilon) {
+                    dropX = true;
+                    break;
+                }
+
+                if (abs(y - mCurrentTouch.pointers[j].y) <= jumpyEpsilon) {
+                    dropY = true;
+                    break;
+                }
+            }
+            if (! dropX && ! dropY) {
+                continue; // not jumpy
+            }
+
+            // Find a replacement candidate by comparing with older points on the
+            // complementary (non-jumpy) axis.
+            int32_t distance = INT_MIN; // distance to be corrected
+            int32_t replacementIndex = -1;
+
+            if (dropX) {
+                // X looks too close.  Find an older replacement point with a close Y.
+                int32_t smallestDeltaY = INT_MAX;
+                for (uint32_t j = 0; j < pointerCount; j++) {
+                    int32_t deltaY = abs(y - mLastTouch.pointers[j].y);
+                    if (deltaY < smallestDeltaY) {
+                        smallestDeltaY = deltaY;
+                        replacementIndex = j;
+                    }
+                }
+                distance = abs(x - mLastTouch.pointers[replacementIndex].x);
+            } else {
+                // Y looks too close.  Find an older replacement point with a close X.
+                int32_t smallestDeltaX = INT_MAX;
+                for (uint32_t j = 0; j < pointerCount; j++) {
+                    int32_t deltaX = abs(x - mLastTouch.pointers[j].x);
+                    if (deltaX < smallestDeltaX) {
+                        smallestDeltaX = deltaX;
+                        replacementIndex = j;
+                    }
+                }
+                distance = abs(y - mLastTouch.pointers[replacementIndex].y);
+            }
+
+            // If replacing this pointer would correct a worse error than the previous ones
+            // considered, then use this replacement instead.
+            if (distance > badPointerDistance) {
+                badPointerIndex = i;
+                badPointerReplacementIndex = replacementIndex;
+                badPointerDistance = distance;
+            }
+        }
+
+        // Correct the jumpy pointer if one was found.
+        if (badPointerIndex >= 0) {
+#if DEBUG_HACKS
+            LOGD("JumpyTouchFilter: Replacing bad pointer %d with (%d, %d)",
+                    badPointerIndex,
+                    mLastTouch.pointers[badPointerReplacementIndex].x,
+                    mLastTouch.pointers[badPointerReplacementIndex].y);
+#endif
+
+            mCurrentTouch.pointers[badPointerIndex].x =
+                    mLastTouch.pointers[badPointerReplacementIndex].x;
+            mCurrentTouch.pointers[badPointerIndex].y =
+                    mLastTouch.pointers[badPointerReplacementIndex].y;
+            mJumpyTouchFilter.jumpyPointsDropped += 1;
+            return true;
+        }
+    }
+
+    mJumpyTouchFilter.jumpyPointsDropped = 0;
+    return false;
+}*/
+
+/* Special hack for devices that have bad screen data: aggregate and
+ * compute averages of the coordinate data, to reduce the amount of
+ * jitter seen by applications. */
+/*void ActiveStylusInputMapper::applyAveragingTouchFilter() {
+    for (uint32_t currentIndex = 0; currentIndex < mCurrentTouch.pointerCount; currentIndex++) {
+        uint32_t id = mCurrentTouch.pointers[currentIndex].id;
+        int32_t x = mCurrentTouch.pointers[currentIndex].x;
+        int32_t y = mCurrentTouch.pointers[currentIndex].y;
+        int32_t pressure;
+        switch (mCalibration.pressureSource) {
+        case Calibration::PRESSURE_SOURCE_PRESSURE:
+            pressure = mCurrentTouch.pointers[currentIndex].pressure;
+            break;
+        case Calibration::PRESSURE_SOURCE_TOUCH:
+            pressure = mCurrentTouch.pointers[currentIndex].touchMajor;
+            break;
+        default:
+            pressure = 1;
+            break;
+        }
+
+        if (mLastTouch.idBits.hasBit(id)) {
+            // Pointer was down before and is still down now.
+            // Compute average over history trace.
+            uint32_t start = mAveragingTouchFilter.historyStart[id];
+            uint32_t end = mAveragingTouchFilter.historyEnd[id];
+
+            int64_t deltaX = x - mAveragingTouchFilter.historyData[end].pointers[id].x;
+            int64_t deltaY = y - mAveragingTouchFilter.historyData[end].pointers[id].y;
+            uint64_t distance = uint64_t(deltaX * deltaX + deltaY * deltaY);
+
+#if DEBUG_HACKS
+            LOGD("AveragingTouchFilter: Pointer id %d - Distance from last sample: %lld",
+                    id, distance);
+#endif
+
+            if (distance < AVERAGING_DISTANCE_LIMIT) {
+                // Increment end index in preparation for recording new historical data.
+                end += 1;
+                if (end > AVERAGING_HISTORY_SIZE) {
+                    end = 0;
+                }
+
+                // If the end index has looped back to the start index then we have filled
+                // the historical trace up to the desired size so we drop the historical
+                // data at the start of the trace.
+                if (end == start) {
+                    start += 1;
+                    if (start > AVERAGING_HISTORY_SIZE) {
+                        start = 0;
+                    }
+                }
+
+                // Add the raw data to the historical trace.
+                mAveragingTouchFilter.historyStart[id] = start;
+                mAveragingTouchFilter.historyEnd[id] = end;
+                mAveragingTouchFilter.historyData[end].pointers[id].x = x;
+                mAveragingTouchFilter.historyData[end].pointers[id].y = y;
+                mAveragingTouchFilter.historyData[end].pointers[id].pressure = pressure;
+
+                // Average over all historical positions in the trace by total pressure.
+                int32_t averagedX = 0;
+                int32_t averagedY = 0;
+                int32_t totalPressure = 0;
+                for (;;) {
+                    int32_t historicalX = mAveragingTouchFilter.historyData[start].pointers[id].x;
+                    int32_t historicalY = mAveragingTouchFilter.historyData[start].pointers[id].y;
+                    int32_t historicalPressure = mAveragingTouchFilter.historyData[start]
+                            .pointers[id].pressure;
+
+                    averagedX += historicalX * historicalPressure;
+                    averagedY += historicalY * historicalPressure;
+                    totalPressure += historicalPressure;
+
+                    if (start == end) {
+                        break;
+                    }
+
+                    start += 1;
+                    if (start > AVERAGING_HISTORY_SIZE) {
+                        start = 0;
+                    }
+                }
+
+                if (totalPressure != 0) {
+                    averagedX /= totalPressure;
+                    averagedY /= totalPressure;
+
+#if DEBUG_HACKS
+                    LOGD("AveragingTouchFilter: Pointer id %d - "
+                            "totalPressure=%d, averagedX=%d, averagedY=%d", id, totalPressure,
+                            averagedX, averagedY);
+#endif
+
+                    mCurrentTouch.pointers[currentIndex].x = averagedX;
+                    mCurrentTouch.pointers[currentIndex].y = averagedY;
+                }
+            } else {
+#if DEBUG_HACKS
+                LOGD("AveragingTouchFilter: Pointer id %d - Exceeded max distance", id);
+#endif
+            }
+        } else {
+#if DEBUG_HACKS
+            LOGD("AveragingTouchFilter: Pointer id %d - Pointer went up", id);
+#endif
+        }
+
+        // Reset pointer history.
+        mAveragingTouchFilter.historyStart[id] = 0;
+        mAveragingTouchFilter.historyEnd[id] = 0;
+        mAveragingTouchFilter.historyData[0].pointers[id].x = x;
+        mAveragingTouchFilter.historyData[0].pointers[id].y = y;
+        mAveragingTouchFilter.historyData[0].pointers[id].pressure = pressure;
+    }
+}*/
+
+int32_t ActiveStylusInputMapper::getKeyCodeState(uint32_t sourceMask, int32_t keyCode) {
+    { // acquire lock
+        AutoMutex _l(mLock);
+
+        if (mLocked.currentVirtualKey.down && mLocked.currentVirtualKey.keyCode == keyCode) {
+            return AKEY_STATE_VIRTUAL;
+        }
+
+        size_t numVirtualKeys = mLocked.virtualKeys.size();
+        for (size_t i = 0; i < numVirtualKeys; i++) {
+            const VirtualKey& virtualKey = mLocked.virtualKeys[i];
+            if (virtualKey.keyCode == keyCode) {
+                return AKEY_STATE_UP;
+            }
+        }
+    } // release lock
+
+    return AKEY_STATE_UNKNOWN;
+}
+
+int32_t ActiveStylusInputMapper::getScanCodeState(uint32_t sourceMask, int32_t scanCode) {
+    { // acquire lock
+        AutoMutex _l(mLock);
+
+        if (mLocked.currentVirtualKey.down && mLocked.currentVirtualKey.scanCode == scanCode) {
+            return AKEY_STATE_VIRTUAL;
+        }
+
+        size_t numVirtualKeys = mLocked.virtualKeys.size();
+        for (size_t i = 0; i < numVirtualKeys; i++) {
+            const VirtualKey& virtualKey = mLocked.virtualKeys[i];
+            if (virtualKey.scanCode == scanCode) {
+                return AKEY_STATE_UP;
+            }
+        }
+    } // release lock
+
+    return AKEY_STATE_UNKNOWN;
+}
+
+bool ActiveStylusInputMapper::markSupportedKeyCodes(uint32_t sourceMask, size_t numCodes,
+        const int32_t* keyCodes, uint8_t* outFlags) {
+    { // acquire lock
+        AutoMutex _l(mLock);
+
+        size_t numVirtualKeys = mLocked.virtualKeys.size();
+        for (size_t i = 0; i < numVirtualKeys; i++) {
+            const VirtualKey& virtualKey = mLocked.virtualKeys[i];
+
+            for (size_t i = 0; i < numCodes; i++) {
+                if (virtualKey.keyCode == keyCodes[i]) {
+                    outFlags[i] = 1;
+                }
+            }
+        }
+    } // release lock
+
+    return true;
+}
+
+int32_t ActiveStylusInputMapper::getMetaState() {
+    { // acquire lock
+        AutoMutex _l(mLock);
+        return mLocked.metaState;
+    } // release lock
+}
+
+// --- SingleActiveStylusInputMapper ---
+
+SingleActiveStylusInputMapper::SingleActiveStylusInputMapper(InputDevice* device, int32_t associatedDisplayId) :
+        ActiveStylusInputMapper(device, associatedDisplayId) {
+    initialize();
+}
+
+SingleActiveStylusInputMapper::~SingleActiveStylusInputMapper() {
+}
+
+void SingleActiveStylusInputMapper::initialize() {
+    mAccumulator.clear();
+
+    mDown = false;
+    mX = 0;
+    mY = 0;
+    mPressure = 0; // default to 0 for devices that don't report pressure
+    mToolWidth = 0; // default to 0 for devices that don't report tool width
+    mToolPen = false;
+    mToolRubber = false;
+    mButtonStylus = false;
+    mButtonStylus2 = false;
+    mInProximity = false;
+}
+
+void SingleActiveStylusInputMapper::reset() {
+    ActiveStylusInputMapper::reset();
+
+    initialize();
+ }
+
+void SingleActiveStylusInputMapper::process(const RawEvent* rawEvent) {
+    switch (rawEvent->type) {
+    case EV_KEY:
+        switch (rawEvent->scanCode) {
+        case BTN_TOUCH:
+            mAccumulator.fields |= Accumulator::FIELD_BTN_TOUCH;
+            mAccumulator.btnTouch = rawEvent->value != 0;
+            // Don't sync immediately.  Wait until the next SYN_REPORT since we might
+            // not have received valid position information yet.  This logic assumes that
+            // BTN_TOUCH is always followed by SYN_REPORT as part of a complete packet.
+            break;
+        case BTN_TOOL_PEN:
+            // Pen tool is being used
+            mAccumulator.fields |= Accumulator::FIELD_BTN_TOOL_PEN;
+            mAccumulator.btnToolPen = rawEvent->value != 0;
+            break;
+        case BTN_TOOL_RUBBER:
+            // Rubber (eraser) tool is being used
+            mAccumulator.fields |= Accumulator::FIELD_BTN_TOOL_RUBBER;
+            mAccumulator.btnToolRubber = rawEvent->value != 0;
+            break;
+        case BTN_STYLUS:
+            // Primary side button has been pressed
+            mAccumulator.fields |= Accumulator::FIELD_BTN_STYLUS;
+            mAccumulator.btnStylus = rawEvent->value != 0;
+            break;
+        case BTN_STYLUS2:
+            // Secondary side button has been pressed
+            mAccumulator.fields |= Accumulator::FIELD_BTN_STYLUS2;
+            mAccumulator.btnStylus2 = rawEvent->value != 0;
+            break;
+        }
+        break;
+
+    case EV_ABS:
+        switch (rawEvent->scanCode) {
+        case ABS_X:
+            mAccumulator.fields |= Accumulator::FIELD_ABS_X;
+            mAccumulator.absX = rawEvent->value;
+            break;
+        case ABS_Y:
+            mAccumulator.fields |= Accumulator::FIELD_ABS_Y;
+            mAccumulator.absY = rawEvent->value;
+            break;
+        case ABS_PRESSURE:
+            mAccumulator.fields |= Accumulator::FIELD_ABS_PRESSURE;
+            mAccumulator.absPressure = rawEvent->value;
+            break;
+        case ABS_TOOL_WIDTH:
+            mAccumulator.fields |= Accumulator::FIELD_ABS_TOOL_WIDTH;
+            mAccumulator.absToolWidth = rawEvent->value;
+            break;
+        }
+        break;
+
+    case EV_SYN:
+        switch (rawEvent->scanCode) {
+        case SYN_REPORT:
+            sync(rawEvent->when);
+            break;
+        }
+        break;
+    }
+}
+
+void SingleActiveStylusInputMapper::sync(nsecs_t when) {
+    uint32_t fields = mAccumulator.fields;
+    if (fields == 0) {
+        return; // no new state changes, so nothing to do
+    }
+
+    if (fields & Accumulator::FIELD_BTN_TOUCH) {
+        mDown = mAccumulator.btnTouch;
+    }
+    
+    if (fields & Accumulator::FIELD_BTN_TOOL_PEN) {
+        mToolPen = mAccumulator.btnToolPen;
+    }
+    
+    if (fields & Accumulator::FIELD_BTN_TOOL_RUBBER) {
+        mToolRubber = mAccumulator.btnToolRubber;
+    }
+
+    mInProximity = mToolPen || mToolRubber;
+    
+    if (fields & Accumulator::FIELD_BTN_STYLUS) {
+        mButtonStylus = mAccumulator.btnStylus;
+    }
+
+    if (fields & Accumulator::FIELD_BTN_STYLUS2) {
+        mButtonStylus2 = mAccumulator.btnStylus2;
+    }
+
+    if (fields & Accumulator::FIELD_ABS_X) {
+        mX = mAccumulator.absX;
+    }
+
+    if (fields & Accumulator::FIELD_ABS_Y) {
+        mY = mAccumulator.absY;
+    }
+
+    if (fields & Accumulator::FIELD_ABS_PRESSURE) {
+        mPressure = mAccumulator.absPressure;
+    }
+
+    if (fields & Accumulator::FIELD_ABS_TOOL_WIDTH) {
+        mToolWidth = mAccumulator.absToolWidth;
+    }
+
+    mCurrentTouch.clear();
+
+    if (mInProximity) {
+        // Stylus in range
+        mCurrentTouch.pointerCount = 1;
+        mCurrentTouch.pointers[0].id = 0;
+        mCurrentTouch.pointers[0].x = mX;
+        mCurrentTouch.pointers[0].y = mY;
+        mCurrentTouch.pointers[0].pressure = mPressure;
+        mCurrentTouch.pointers[0].touchMajor = 0;
+        mCurrentTouch.pointers[0].touchMinor = 0;
+        mCurrentTouch.pointers[0].toolMajor = mToolWidth;
+        mCurrentTouch.pointers[0].toolMinor = mToolWidth;
+        mCurrentTouch.pointers[0].orientation = 0;
+        mCurrentTouch.pointers[0].buttonStylus = mButtonStylus;
+        mCurrentTouch.pointers[0].buttonStylus2 = mButtonStylus2;
+        if (mToolPen) {
+            mCurrentTouch.pointers[0].toolType = AMOTION_EVENT_TOOL_TYPE_PEN;
+        } else if (mToolRubber) {
+            mCurrentTouch.pointers[0].toolType = AMOTION_EVENT_TOOL_TYPE_RUBBER;
+        } else {
+            mCurrentTouch.pointers[0].toolType = AMOTION_EVENT_TOOL_TYPE_NONE;
+        }
+        mCurrentTouch.idToIndex[0] = 0;
+
+        if (mDown) {
+            // Stylus down
+            mCurrentTouch.idBits.markBit(0);
+        } else {
+            // Stylus up
+            mCurrentTouch.idBits.clearBit(0);
+        }
+    
+        LOGD("%s - x: %d y: %d pressure: %d side 1: %d side 2: %d", (mToolPen) ? "pen" : "eraser", mX, mY, mPressure, mButtonStylus, mButtonStylus2);
+    } else {
+        // Stylus not in range
+        mCurrentTouch.pointerCount = 0;
+        
+        LOGD("out - x: %d y: %d pressure: %d side 1: %d side 2: %d", mX, mY, mPressure, mButtonStylus, mButtonStylus2);
+    }
+
+    syncTouch(when, true);
+
+    mAccumulator.clear();
+}
+
+/*void SingleActiveStylusInputMapper::syncStylus(nsecs_t when) {
+    uint32_t fields = mAccumulator.fields;
+    if (fields == 0) {
+        return; // no new state changes, so nothing to do
+    }
+
+    int motionEventAction;
+    PointerCoords pointerCoords;
+    nsecs_t downTime;
+    { // acquire lock
+        AutoMutex _l(mLock);
+
+        bool downChanged = false;
+
+        if (fields & Accumulator::FIELD_BTN_TOUCH) {
+           downChaged = mLastEventDown != mDown;
+        }
+
+        if (downChanged) {
+            if (mAccumulator.btnTouch) {
+                mLocked.down = true;
+                mLocked.downTime = when;
+            } else {
+                mLocked.down = false;
+            }
+        }
+
+        downTime = mLocked.downTime;
+        float x = fields & Accumulator::FIELD_REL_X ? mAccumulator.relX * mXScale : 0.0f;
+        float y = fields & Accumulator::FIELD_REL_Y ? mAccumulator.relY * mYScale : 0.0f;
+
+        if (downChanged) {
+            motionEventAction = mLocked.down ? AMOTION_EVENT_ACTION_DOWN : AMOTION_EVENT_ACTION_UP;
+        } else {
+            motionEventAction = AMOTION_EVENT_ACTION_MOVE;
+        }
+
+        pointerCoords.x = x;
+        pointerCoords.y = y;
+        pointerCoords.pressure = mLocked.down ? 1.0f : 0.0f;
+        pointerCoords.size = 0;
+        pointerCoords.touchMajor = 0;
+        pointerCoords.touchMinor = 0;
+        pointerCoords.toolMajor = 0;
+        pointerCoords.toolMinor = 0;
+        pointerCoords.orientation = 0;
+
+        if (mAssociatedDisplayId >= 0 && (x != 0.0f || y != 0.0f)) {
+            // Rotate motion based on display orientation if needed.
+            // Note: getDisplayInfo is non-reentrant so we can continue holding the lock.
+            int32_t orientation;
+            if (! getPolicy()->getDisplayInfo(mAssociatedDisplayId, NULL, NULL, & orientation)) {
+                return;
+            }
+
+            float temp;
+            switch (orientation) {
+            case InputReaderPolicyInterface::ROTATION_90:
+                temp = pointerCoords.x;
+                pointerCoords.x = pointerCoords.y;
+                pointerCoords.y = - temp;
+                break;
+
+            case InputReaderPolicyInterface::ROTATION_180:
+                pointerCoords.x = - pointerCoords.x;
+                pointerCoords.y = - pointerCoords.y;
+                break;
+
+            case InputReaderPolicyInterface::ROTATION_270:
+                temp = pointerCoords.x;
+                pointerCoords.x = - pointerCoords.y;
+                pointerCoords.y = temp;
+                break;
+            }
+        }
+    } // release lock
+
+    int32_t metaState = mContext->getGlobalMetaState();
+    int32_t pointerId = 0;
+    getDispatcher()->notifyMotion(when, getDeviceId(), AINPUT_SOURCE_TRACKBALL, 0,
+            motionEventAction, AMOTION_EVENT_TOOL_TYPE_PEN, 0, metaState, AMOTION_EVENT_EDGE_FLAG_NONE,
+            1, &pointerId, &pointerCoords, mXPrecision, mYPrecision, downTime);
+
+    mAccumulator.clear();
+}*/
+
+void SingleActiveStylusInputMapper::configureRawAxes() {
+    ActiveStylusInputMapper::configureRawAxes();
+
+    getEventHub()->getAbsoluteAxisInfo(getDeviceId(), ABS_X, & mRawAxes.x);
+    getEventHub()->getAbsoluteAxisInfo(getDeviceId(), ABS_Y, & mRawAxes.y);
+    getEventHub()->getAbsoluteAxisInfo(getDeviceId(), ABS_PRESSURE, & mRawAxes.pressure);
+    getEventHub()->getAbsoluteAxisInfo(getDeviceId(), ABS_TOOL_WIDTH, & mRawAxes.toolMajor);
+}
 
 } // namespace android
diff --git a/libs/ui/InputTransport.cpp b/libs/ui/InputTransport.cpp
index 2c6346e..a75dc9b 100644
--- a/libs/ui/InputTransport.cpp
+++ b/libs/ui/InputTransport.cpp
@@ -353,6 +353,7 @@ status_t InputPublisher::publishMotionEvent(
         int32_t deviceId,
         int32_t source,
         int32_t action,
+        int32_t toolType,
         int32_t flags,
         int32_t edgeFlags,
         int32_t metaState,
@@ -367,11 +368,11 @@ status_t InputPublisher::publishMotionEvent(
         const PointerCoords* pointerCoords) {
 #if DEBUG_TRANSPORT_ACTIONS
     LOGD("channel '%s' publisher ~ publishMotionEvent: deviceId=%d, source=0x%x, "
-            "action=0x%x, flags=0x%x, edgeFlags=0x%x, metaState=0x%x, xOffset=%f, yOffset=%f, "
+            "action=0x%x, toolType=0x%x, flags=0x%x, edgeFlags=0x%x, metaState=0x%x, xOffset=%f, yOffset=%f, "
             "xPrecision=%f, yPrecision=%f, downTime=%lld, eventTime=%lld, "
             "pointerCount=%d",
             mChannel->getName().string(),
-            deviceId, source, action, flags, edgeFlags, metaState, xOffset, yOffset,
+            deviceId, source, action, toolType, flags, edgeFlags, metaState, xOffset, yOffset,
             xPrecision, yPrecision, downTime, eventTime, pointerCount);
 #endif
 
@@ -387,6 +388,7 @@ status_t InputPublisher::publishMotionEvent(
     }
 
     mSharedMessage->motion.action = action;
+    mSharedMessage->motion.toolType = toolType;
     mSharedMessage->motion.flags = flags;
     mSharedMessage->motion.edgeFlags = edgeFlags;
     mSharedMessage->motion.metaState = metaState;
@@ -673,6 +675,7 @@ void InputConsumer::populateMotionEvent(MotionEvent* motionEvent) const {
             mSharedMessage->deviceId,
             mSharedMessage->source,
             mSharedMessage->motion.action,
+            mSharedMessage->motion.toolType,
             mSharedMessage->motion.flags,
             mSharedMessage->motion.edgeFlags,
             mSharedMessage->motion.metaState,
diff --git a/libs/ui/tests/InputDispatcher_test.cpp b/libs/ui/tests/InputDispatcher_test.cpp
index 9edf956..f4054df 100644
--- a/libs/ui/tests/InputDispatcher_test.cpp
+++ b/libs/ui/tests/InputDispatcher_test.cpp
@@ -133,7 +133,7 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
 
     // Rejects undefined motion actions.
     event.initialize(DEVICE_ID, AINPUT_SOURCE_TOUCHSCREEN,
-            /*action*/ -1, 0, 0, AMETA_NONE, 0, 0, 0, 0,
+            /*action*/ -1, 0, 0, 0, AMETA_NONE, 0, 0, 0, 0,
             ARBITRARY_TIME, ARBITRARY_TIME,
             /*pointerCount*/ 1, pointerIds, pointerCoords);
     ASSERT_EQ(INPUT_EVENT_INJECTION_FAILED, mDispatcher->injectInputEvent(&event,
@@ -143,7 +143,7 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
     // Rejects pointer down with invalid index.
     event.initialize(DEVICE_ID, AINPUT_SOURCE_TOUCHSCREEN,
             AMOTION_EVENT_ACTION_POINTER_DOWN | (1 << AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT),
-            0, 0, AMETA_NONE, 0, 0, 0, 0,
+            0, 0, 0, AMETA_NONE, 0, 0, 0, 0,
             ARBITRARY_TIME, ARBITRARY_TIME,
             /*pointerCount*/ 1, pointerIds, pointerCoords);
     ASSERT_EQ(INPUT_EVENT_INJECTION_FAILED, mDispatcher->injectInputEvent(&event,
@@ -152,7 +152,7 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
 
     event.initialize(DEVICE_ID, AINPUT_SOURCE_TOUCHSCREEN,
             AMOTION_EVENT_ACTION_POINTER_DOWN | (-1 << AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT),
-            0, 0, AMETA_NONE, 0, 0, 0, 0,
+            0, 0, 0, AMETA_NONE, 0, 0, 0, 0,
             ARBITRARY_TIME, ARBITRARY_TIME,
             /*pointerCount*/ 1, pointerIds, pointerCoords);
     ASSERT_EQ(INPUT_EVENT_INJECTION_FAILED, mDispatcher->injectInputEvent(&event,
@@ -162,7 +162,7 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
     // Rejects pointer up with invalid index.
     event.initialize(DEVICE_ID, AINPUT_SOURCE_TOUCHSCREEN,
             AMOTION_EVENT_ACTION_POINTER_UP | (1 << AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT),
-            0, 0, AMETA_NONE, 0, 0, 0, 0,
+            0, 0, 0, AMETA_NONE, 0, 0, 0, 0,
             ARBITRARY_TIME, ARBITRARY_TIME,
             /*pointerCount*/ 1, pointerIds, pointerCoords);
     ASSERT_EQ(INPUT_EVENT_INJECTION_FAILED, mDispatcher->injectInputEvent(&event,
@@ -171,7 +171,7 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
 
     event.initialize(DEVICE_ID, AINPUT_SOURCE_TOUCHSCREEN,
             AMOTION_EVENT_ACTION_POINTER_UP | (-1 << AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT),
-            0, 0, AMETA_NONE, 0, 0, 0, 0,
+            0, 0, 0, AMETA_NONE, 0, 0, 0, 0,
             ARBITRARY_TIME, ARBITRARY_TIME,
             /*pointerCount*/ 1, pointerIds, pointerCoords);
     ASSERT_EQ(INPUT_EVENT_INJECTION_FAILED, mDispatcher->injectInputEvent(&event,
@@ -180,7 +180,7 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
 
     // Rejects motion events with invalid number of pointers.
     event.initialize(DEVICE_ID, AINPUT_SOURCE_TOUCHSCREEN,
-            AMOTION_EVENT_ACTION_DOWN, 0, 0, AMETA_NONE, 0, 0, 0, 0,
+            AMOTION_EVENT_ACTION_DOWN, 0, 0, 0, AMETA_NONE, 0, 0, 0, 0,
             ARBITRARY_TIME, ARBITRARY_TIME,
             /*pointerCount*/ 0, pointerIds, pointerCoords);
     ASSERT_EQ(INPUT_EVENT_INJECTION_FAILED, mDispatcher->injectInputEvent(&event,
@@ -188,7 +188,7 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
             << "Should reject motion events with 0 pointers.";
 
     event.initialize(DEVICE_ID, AINPUT_SOURCE_TOUCHSCREEN,
-            AMOTION_EVENT_ACTION_DOWN, 0, 0, AMETA_NONE, 0, 0, 0, 0,
+            AMOTION_EVENT_ACTION_DOWN, 0, 0, 0, AMETA_NONE, 0, 0, 0, 0,
             ARBITRARY_TIME, ARBITRARY_TIME,
             /*pointerCount*/ MAX_POINTERS + 1, pointerIds, pointerCoords);
     ASSERT_EQ(INPUT_EVENT_INJECTION_FAILED, mDispatcher->injectInputEvent(&event,
@@ -198,7 +198,7 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
     // Rejects motion events with invalid pointer ids.
     pointerIds[0] = -1;
     event.initialize(DEVICE_ID, AINPUT_SOURCE_TOUCHSCREEN,
-            AMOTION_EVENT_ACTION_DOWN, 0, 0, AMETA_NONE, 0, 0, 0, 0,
+            AMOTION_EVENT_ACTION_DOWN, 0, 0, 0, AMETA_NONE, 0, 0, 0, 0,
             ARBITRARY_TIME, ARBITRARY_TIME,
             /*pointerCount*/ 1, pointerIds, pointerCoords);
     ASSERT_EQ(INPUT_EVENT_INJECTION_FAILED, mDispatcher->injectInputEvent(&event,
@@ -207,7 +207,7 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
 
     pointerIds[0] = MAX_POINTER_ID + 1;
     event.initialize(DEVICE_ID, AINPUT_SOURCE_TOUCHSCREEN,
-            AMOTION_EVENT_ACTION_DOWN, 0, 0, AMETA_NONE, 0, 0, 0, 0,
+            AMOTION_EVENT_ACTION_DOWN, 0, 0, 0, AMETA_NONE, 0, 0, 0, 0,
             ARBITRARY_TIME, ARBITRARY_TIME,
             /*pointerCount*/ 1, pointerIds, pointerCoords);
     ASSERT_EQ(INPUT_EVENT_INJECTION_FAILED, mDispatcher->injectInputEvent(&event,
@@ -218,7 +218,7 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
     pointerIds[0] = 1;
     pointerIds[1] = 1;
     event.initialize(DEVICE_ID, AINPUT_SOURCE_TOUCHSCREEN,
-            AMOTION_EVENT_ACTION_DOWN, 0, 0, AMETA_NONE, 0, 0, 0, 0,
+            AMOTION_EVENT_ACTION_DOWN, 0, 0, 0, AMETA_NONE, 0, 0, 0, 0,
             ARBITRARY_TIME, ARBITRARY_TIME,
             /*pointerCount*/ 2, pointerIds, pointerCoords);
     ASSERT_EQ(INPUT_EVENT_INJECTION_FAILED, mDispatcher->injectInputEvent(&event,
diff --git a/libs/ui/tests/InputPublisherAndConsumer_test.cpp b/libs/ui/tests/InputPublisherAndConsumer_test.cpp
index 952b974..57eff3c 100644
--- a/libs/ui/tests/InputPublisherAndConsumer_test.cpp
+++ b/libs/ui/tests/InputPublisherAndConsumer_test.cpp
@@ -138,6 +138,7 @@ void InputPublisherAndConsumerTest::PublishAndConsumeMotionEvent(
     const int32_t deviceId = 1;
     const int32_t source = AINPUT_SOURCE_TOUCHSCREEN;
     const int32_t action = AMOTION_EVENT_ACTION_MOVE;
+    const int32_t toolType = AMOTION_EVENT_TOOL_TYPE_NONE;
     const int32_t flags = AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED;
     const int32_t edgeFlags = AMOTION_EVENT_EDGE_FLAG_TOP;
     const int32_t metaState = AMETA_ALT_LEFT_ON | AMETA_ALT_ON;
@@ -168,7 +169,7 @@ void InputPublisherAndConsumerTest::PublishAndConsumeMotionEvent(
         }
     }
 
-    status = mPublisher->publishMotionEvent(deviceId, source, action, flags, edgeFlags,
+    status = mPublisher->publishMotionEvent(deviceId, source, action, toolType, flags, edgeFlags,
             metaState, xOffset, yOffset, xPrecision, yPrecision,
             downTime, sampleEventTimes[0], pointerCount, pointerIds, samplePointerCoords.array());
     ASSERT_EQ(OK, status)
@@ -214,6 +215,7 @@ void InputPublisherAndConsumerTest::PublishAndConsumeMotionEvent(
     EXPECT_EQ(deviceId, motionEvent->getDeviceId());
     EXPECT_EQ(source, motionEvent->getSource());
     EXPECT_EQ(action, motionEvent->getAction());
+    EXPECT_EQ(toolType, motionEvent->getToolType());
     EXPECT_EQ(flags, motionEvent->getFlags());
     EXPECT_EQ(edgeFlags, motionEvent->getEdgeFlags());
     EXPECT_EQ(metaState, motionEvent->getMetaState());
@@ -324,12 +326,12 @@ TEST_F(InputPublisherAndConsumerTest, PublishMotionEvent_WhenNotReset_ReturnsErr
     int32_t pointerIds[pointerCount] = { 0 };
     PointerCoords pointerCoords[pointerCount] = { { 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
 
-    status = mPublisher->publishMotionEvent(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    status = mPublisher->publishMotionEvent(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
             pointerCount, pointerIds, pointerCoords);
     ASSERT_EQ(OK, status)
             << "publisher publishMotionEvent should return OK";
 
-    status = mPublisher->publishMotionEvent(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    status = mPublisher->publishMotionEvent(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
             pointerCount, pointerIds, pointerCoords);
     ASSERT_EQ(INVALID_OPERATION, status)
             << "publisher publishMotionEvent should return INVALID_OPERATION because ";
@@ -344,7 +346,7 @@ TEST_F(InputPublisherAndConsumerTest, PublishMotionEvent_WhenPointerCountLessTha
     int32_t pointerIds[pointerCount];
     PointerCoords pointerCoords[pointerCount];
 
-    status = mPublisher->publishMotionEvent(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    status = mPublisher->publishMotionEvent(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
             pointerCount, pointerIds, pointerCoords);
     ASSERT_EQ(BAD_VALUE, status)
             << "publisher publishMotionEvent should return BAD_VALUE";
@@ -358,7 +360,7 @@ TEST_F(InputPublisherAndConsumerTest, PublishMotionEvent_WhenPointerCountGreater
     int32_t pointerIds[pointerCount];
     PointerCoords pointerCoords[pointerCount];
 
-    status = mPublisher->publishMotionEvent(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    status = mPublisher->publishMotionEvent(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
             pointerCount, pointerIds, pointerCoords);
     ASSERT_EQ(BAD_VALUE, status)
             << "publisher publishMotionEvent should return BAD_VALUE";
@@ -403,7 +405,7 @@ TEST_F(InputPublisherAndConsumerTest, AppendMotionSample_WhenPublishedMotionEven
     int32_t pointerIds[pointerCount];
     PointerCoords pointerCoords[pointerCount];
 
-    status = mPublisher->publishMotionEvent(0, 0, AMOTION_EVENT_ACTION_DOWN,
+    status = mPublisher->publishMotionEvent(0, 0, AMOTION_EVENT_ACTION_DOWN, 0,
             0, 0, 0, 0, 0, 0, 0, 0, 0, pointerCount, pointerIds, pointerCoords);
     ASSERT_EQ(OK, status);
 
@@ -420,7 +422,7 @@ TEST_F(InputPublisherAndConsumerTest, AppendMotionSample_WhenAlreadyConsumed_Ret
     int32_t pointerIds[pointerCount];
     PointerCoords pointerCoords[pointerCount];
 
-    status = mPublisher->publishMotionEvent(0, 0, AMOTION_EVENT_ACTION_MOVE,
+    status = mPublisher->publishMotionEvent(0, 0, AMOTION_EVENT_ACTION_MOVE, 0,
             0, 0, 0, 0, 0, 0, 0, 0, 0, pointerCount, pointerIds, pointerCoords);
     ASSERT_EQ(OK, status);
 
@@ -447,7 +449,7 @@ TEST_F(InputPublisherAndConsumerTest, AppendMotionSample_WhenBufferFull_ReturnsE
     int32_t pointerIds[pointerCount];
     PointerCoords pointerCoords[pointerCount];
 
-    status = mPublisher->publishMotionEvent(0, 0, AMOTION_EVENT_ACTION_MOVE,
+    status = mPublisher->publishMotionEvent(0, 0, AMOTION_EVENT_ACTION_MOVE, 0,
             0, 0, 0, 0, 0, 0, 0, 0, 0, pointerCount, pointerIds, pointerCoords);
     ASSERT_EQ(OK, status);
 
diff --git a/libs/ui/tests/InputReader_test.cpp b/libs/ui/tests/InputReader_test.cpp
index de4b05a..2bcc523 100644
--- a/libs/ui/tests/InputReader_test.cpp
+++ b/libs/ui/tests/InputReader_test.cpp
@@ -180,6 +180,7 @@ public:
         int32_t source;
         uint32_t policyFlags;
         int32_t action;
+        int32_t toolType;
         int32_t flags;
         int32_t metaState;
         int32_t edgeFlags;
@@ -282,7 +283,7 @@ private:
     }
 
     virtual void notifyMotion(nsecs_t eventTime, int32_t deviceId, int32_t source,
-            uint32_t policyFlags, int32_t action, int32_t flags,
+            uint32_t policyFlags, int32_t action, int32_t toolType, int32_t flags,
             int32_t metaState, int32_t edgeFlags,
             uint32_t pointerCount, const int32_t* pointerIds, const PointerCoords* pointerCoords,
             float xPrecision, float yPrecision, nsecs_t downTime) {
@@ -292,6 +293,7 @@ private:
         args.source = source;
         args.policyFlags = policyFlags;
         args.action = action;
+        args.toolType = toolType;
         args.flags = flags;
         args.metaState = metaState;
         args.edgeFlags = edgeFlags;
diff --git a/native/android/input.cpp b/native/android/input.cpp
index c753aa5..76fa0a9 100644
--- a/native/android/input.cpp
+++ b/native/android/input.cpp
@@ -84,6 +84,10 @@ int32_t AMotionEvent_getAction(const AInputEvent* motion_event) {
     return static_cast<const MotionEvent*>(motion_event)->getAction();
 }
 
+int32_t AMotionEvent_getToolType(const AInputEvent* motion_event) {
+    return static_cast<const MotionEvent*>(motion_event)->getToolType();
+}
+
 int32_t AMotionEvent_getFlags(const AInputEvent* motion_event) {
     return static_cast<const MotionEvent*>(motion_event)->getFlags();
 }
diff --git a/native/include/android/input.h b/native/include/android/input.h
index 7df13c3..a657e8c 100644
--- a/native/include/android/input.h
+++ b/native/include/android/input.h
@@ -93,7 +93,13 @@ enum {
     AMETA_SHIFT_RIGHT_ON = 0x80,
 
     /* This mask is used to check whether the SYM meta key is pressed. */
-    AMETA_SYM_ON = 0x04
+    AMETA_SYM_ON = 0x04,
+    
+    /* This mask is used to check whether the primary stylus button is pressed. */
+    AMETA_BTN_STYLUS_ON = 0x100,
+    
+    /* This mask is used to check whether the secondary stylus button is pressed. */
+    AMETA_BTN_STYLUS2_ON = 0x200
 };
 
 /*
@@ -243,7 +249,40 @@ enum {
     /* A non-primary pointer has gone up.
      * The bits in AMOTION_EVENT_ACTION_POINTER_INDEX_MASK indicate which pointer changed.
      */
-    AMOTION_EVENT_ACTION_POINTER_UP = 6
+    AMOTION_EVENT_ACTION_POINTER_UP = 6,
+
+    /* The InputDevice is hovering above but not touching the surface.
+     * The motion contains the most recent point, as well as any intermediate points
+     * since the last up or hover event (similar to an AMOTION_EVENT_ACTION_MOVE). 
+     * This will only occur between an AMOTION_EVENT_ACTION_UP and AMOTION_EVENT_ACTION_DOWN
+     * for InputDevices that support hover.
+     */
+    AMOTION_EVENT_ACTION_HOVER = 7,
+
+    /* TODO: add comment
+     */
+    AMOTION_EVENT_ACTION_ENTER_PROXIMITY = 8,
+
+    /* TODO: add comment
+     */
+    AMOTION_EVENT_ACTION_EXIT_PROXIMITY = 9
+};
+
+/*
+ * Motion event tool types.
+ */
+enum {
+    /* TODO: add comment
+     */
+    AMOTION_EVENT_TOOL_TYPE_NONE = 0,
+
+    /* TODO: add comment
+     */
+    AMOTION_EVENT_TOOL_TYPE_PEN = 1,
+
+    /* TODO: add comment
+     */
+    AMOTION_EVENT_TOOL_TYPE_RUBBER = 2
 };
 
 /*
@@ -306,6 +345,7 @@ enum {
     AINPUT_SOURCE_MOUSE = 0x00002000 | AINPUT_SOURCE_CLASS_POINTER,
     AINPUT_SOURCE_TRACKBALL = 0x00010000 | AINPUT_SOURCE_CLASS_NAVIGATION,
     AINPUT_SOURCE_TOUCHPAD = 0x00100000 | AINPUT_SOURCE_CLASS_POSITION,
+    AINPUT_SOURCE_ACTIVE_STYLUS = 0x00200000 | AINPUT_SOURCE_CLASS_POINTER,
 
     AINPUT_SOURCE_ANY = 0xffffff00,
 };
@@ -409,6 +449,9 @@ int64_t AKeyEvent_getEventTime(const AInputEvent* key_event);
 /* Get the combined motion event action code and pointer index. */
 int32_t AMotionEvent_getAction(const AInputEvent* motion_event);
 
+/* Get the motion event tool type. */
+int32_t AMotionEvent_getToolType(const AInputEvent* motion_event);
+
 /* Get the motion event flags. */
 int32_t AMotionEvent_getFlags(const AInputEvent* motion_event);
 
diff --git a/native/include/android/keycodes.h b/native/include/android/keycodes.h
index 496eccc..69f2441 100644
--- a/native/include/android/keycodes.h
+++ b/native/include/android/keycodes.h
@@ -154,6 +154,8 @@ enum {
     AKEYCODE_BUTTON_START    = 108,
     AKEYCODE_BUTTON_SELECT   = 109,
     AKEYCODE_BUTTON_MODE     = 110,
+    AKEYCODE_BUTTON_STYLUS   = 111,
+    AKEYCODE_BUTTON_STYLUS2  = 112,
 
     // NOTE: If you add a new keycode here you must also add it to several other files.
     //       Refer to frameworks/base/core/java/android/view/KeyEvent.java for the full list.
diff --git a/services/java/com/android/server/InputManager.java b/services/java/com/android/server/InputManager.java
index df41264..7336859 100644
--- a/services/java/com/android/server/InputManager.java
+++ b/services/java/com/android/server/InputManager.java
@@ -524,11 +524,12 @@ public class InputManager {
         public int getMaxEventsPerSecond() {
             int result = 0;
             try {
-                result = Integer.parseInt(SystemProperties.get("windowsmgr.max_events_per_sec"));
+                // TODO: do this properly
+                //result = Integer.parseInt(SystemProperties.get("windowsmgr.max_events_per_sec"));
             } catch (NumberFormatException e) {
             }
             if (result < 1) {
-                result = 60;
+                result = 150;
             }
             return result;
         }
diff --git a/services/java/com/android/server/PointerManagerService.java b/services/java/com/android/server/PointerManagerService.java
new file mode 100644
index 0000000..a7e401d
--- /dev/null
+++ b/services/java/com/android/server/PointerManagerService.java
@@ -0,0 +1,390 @@
+package com.android.server;
+
+import com.android.internal.view.BaseInputHandler;
+
+import android.app.IPointerManager;
+import android.app.Pointer;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.content.res.Resources;
+import android.os.Handler;
+import android.os.RemoteException;
+import android.os.Looper;
+import android.util.Slog;
+import android.view.IWindowManager;
+import android.view.InputChannel;
+import android.view.InputDevice;
+import android.view.InputHandler;
+import android.view.InputQueue;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+
+import android.graphics.Canvas;
+import android.graphics.drawable.Drawable;
+import android.graphics.Matrix;
+import android.graphics.Path;
+import android.graphics.Paint;
+import android.graphics.PixelFormat;
+
+import android.view.Surface;
+import android.view.SurfaceSession;
+
+/** {@hide} */
+public class PointerManagerService extends IPointerManager.Stub {
+    static final String TAG = "PointerManager";
+    static final boolean DEBUG = true;
+
+    Object mLock = new Object();
+
+    final Context mContext;
+
+    final Handler mHandler;
+    final IWindowManager mWindowManager;
+    InputChannel mInputChannel; // couldn't make final (wouldn't compile) because it _might_ not be initialized
+
+    Pointer mPointer;
+    final Pointer mDefaultPointer;
+    final Pointer mDefaultPointerSidePressed;
+
+    Surface mPointerSurface;
+    Canvas mCanvas;
+    //Path mPath;
+    Paint mPaint;
+
+    private float mX = 0; // TODO: intitialize to middle of display
+    private float mY = 0; // TODO: intitialize to middle of display
+
+    private String mCurrentPkg = null;
+    private boolean mVisible = true;
+    private boolean mPointerInRange = true;
+    private boolean mButtonStylus = false;
+    private boolean mButtonStylus2 = false;
+
+    final InputHandler mInputHandler = new BaseInputHandler() {
+        @Override
+        public void handleMotion(MotionEvent event, Runnable finishedCallback) {
+            try {
+                int source = event.getSource();
+                if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {
+                    dispatchPointer(event);
+                } else {
+                    Slog.i(TAG, "Event type: " + source);
+                }
+            } finally {
+                finishedCallback.run();
+            }
+        }
+    };
+
+    public PointerManagerService(Context context, IWindowManager windowManager) {
+        if (DEBUG) Slog.v(TAG, "PointerManagerService startup");
+        mContext = context;
+        //mIWindowManager = IWindowManager.Stub.asInterface(
+        //        ServiceManager.getService(Context.WINDOW_SERVICE));
+        
+        mWindowManager = windowManager;
+        mHandler = new Handler();
+        try {
+            mInputChannel = mWindowManager.monitorInput("PointerManager");
+            InputQueue.registerInputChannel(mInputChannel, mInputHandler,
+                    mHandler.getLooper().myQueue());
+            Slog.i(TAG, "InputChannel and InputQueue initialized");
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Could not set up input monitoring for PointerManager", e);
+        } catch (Exception e) {
+            Slog.e(TAG, "Failed to register input channel", e);
+        }
+        mDefaultPointer = new Pointer(com.android.internal.R.drawable.pointer, 9, 9);
+        mDefaultPointerSidePressed = new Pointer(com.android.internal.R.drawable.pointer_side_button_pressed, 15, 15);
+        mPointer = mDefaultPointer;
+        try {
+            // Surface paramenters
+            SurfaceSession s = new SurfaceSession();
+            int pid = 0;
+            String name = "PointerSurface";
+            int display = -1; //?
+            int w = 5;
+            int h = 5;
+            int format = PixelFormat.TRANSPARENT;
+            int flags = Surface.FX_SURFACE_NORMAL;
+
+            mPointerSurface = new Surface(s, pid, name, display, 
+                    w, h, format, flags);
+            mCanvas = mPointerSurface.lockCanvas(null);
+            mCanvas.drawColor(0x0); // fill canvas with transparent
+            mPointerSurface.unlockCanvasAndPost(mCanvas);
+            
+            //mPath = new Path();
+            //mPath.moveTo(0.0f, 0.0f);
+            //mPath.lineTo(16.0f, 0.0f);
+            //mPath.lineTo(0.0f, 16.0f);
+            //mPath.close();
+            //mCanvas.clipPath(mPath);
+            //mCanvas.drawColor(0x66666666);
+
+            /*
+            mPaint = new Paint();
+            mPaint.setAntiAlias(true);
+            mPaint.setColor(0xaa000000);
+            mPaint.setStyle(Paint.Style.FILL);
+
+            mCanvas.drawCircle(2.5f, 2.5f, 2.0f, mPaint);
+            mCanvas.drawLine(2.5f, 0.0f, 2.5f, 5.0f, mPaint);
+            mCanvas.drawLine(0.0f, 2.5f, 5.0f, 2.5f, mPaint);
+
+            mPointerSurface.unlockCanvasAndPost(mCanvas);
+            mPointerSurface.openTransaction();
+            mPointerSurface.setSize(w, h);
+            mPointerSurface.closeTransaction();
+            */
+
+            resetPointer();
+
+            Slog.i(TAG, "PointerSurface initialized");
+        } catch (Exception e) {
+            Slog.e(TAG, "Exception creating pointer surface", e);
+        }
+        Slog.i(TAG, "PointerManager initialized");
+    }
+    
+    public void systemReady() {
+        if (DEBUG) Slog.v(TAG, "systemReady");
+        synchronized (mLock) {
+            try {
+
+            } catch (RuntimeException e) {
+                Slog.w(TAG, "Failure ", e);
+            }
+        }
+    }
+
+    public void changePointer(String pkg, Pointer pointer) {
+        synchronized (mLock) {
+            setPointerLocked(pkg, pointer);
+        }
+        Slog.w(TAG, "Successfully set pointer: " + pointer.toString());
+    }
+
+    public void setVisible(String pkg, boolean visible) {
+        synchronized (mLock) {
+            mCurrentPkg = pkg;
+            mVisible = visible;
+
+            // TODO: only show/hide if mVisible != visible?
+
+            Surface.openTransaction();
+            try {
+                if (visible) {
+                    mPointerSurface.hide();
+                } else {
+                    mPointerSurface.show();
+                }
+            } catch (Exception e) {
+                Slog.w(TAG, "Failed to hide pointer surface ", e);
+            } finally {
+                Surface.closeTransaction();
+            }
+        }
+        Slog.w(TAG, "Successfully set pointer visibility to: " + visible);
+    }
+
+    // TODO: don't pass in pkg?
+    public void resetPointer(String pkg) {
+        synchronized (mLock) {
+            setPointerLocked(null, mDefaultPointer);
+            mVisible = true;
+        }
+        Slog.w(TAG, "Successfully reset pointer");
+    }
+    
+    private void resetPointer() {
+        resetPointer(null);
+    }
+    
+    private boolean setPointerLocked(Pointer p) {
+        if (!setPointerLocked(null, p)) {
+            resetPointer();
+            return false;
+        }
+        return true;
+    }
+
+    private boolean setPointerLocked(String pkg, Pointer p) {
+        Drawable d;
+        if (pkg == null) {
+            d = mContext.getResources().getDrawable(p.getImage());
+        } else {
+            PackageManager pm = mContext.getPackageManager();
+            Resources res;
+            try {
+                res = pm.getResourcesForApplication(pkg);
+            } catch (PackageManager.NameNotFoundException e) {
+                // shouldn't happen -- somehow package was uninstalled
+                // immediately after pointer change request
+                return false;
+            }
+            try {
+                d = res.getDrawable(p.getImage());
+            } catch (Resources.NotFoundException e) {
+                // invalid resource
+                return false;
+            }
+        }
+
+        setPointerDrawableLocked(d);
+       
+        int x = (int)(mX - p.getOffsetX());
+        int y = (int)(mY - p.getOffsetY());
+
+        Surface.openTransaction();
+        try {
+            mPointerSurface.setPosition(x, y);
+        } catch (Exception e) {
+            Slog.w(TAG, "Failed to set position of pointer surface", e);
+        } finally {
+            Surface.closeTransaction();
+        }
+
+        mCurrentPkg = pkg;
+        mPointer = p;
+
+        return true;
+    }
+
+    private void setPointerDrawableLocked(Drawable d) {
+        int w = d.getIntrinsicWidth();
+        int h = d.getIntrinsicHeight();
+        
+        Slog.w(TAG, "Drawable width: " + w + " height: " + h);
+        
+        int mw = d.getIntrinsicWidth();
+        int mh = d.getIntrinsicHeight();
+        
+        Slog.w(TAG, "Drawable min width: " + mw + " min height: " + mh);
+
+        d.setBounds(0, 0, w, h);
+        
+        Surface.openTransaction();
+        try {
+            mPointerSurface.setSize(w, h);
+        } catch (Exception e) {
+            Slog.w(TAG, "Failed to set size of pointer surface", e);
+        } finally {
+            Surface.closeTransaction();
+        }
+
+        try {
+            mCanvas = mPointerSurface.lockCanvas(null);
+            mCanvas.drawColor(0x0); // fill canvas with transparent
+            d.draw(mCanvas);
+            mPointerSurface.unlockCanvasAndPost(mCanvas);
+        } catch (Exception e) {
+            Slog.w(TAG, "Failed to update pointer surface with drawable", e);
+        }
+    }
+
+    /*@Override
+    protected void finalize() throws Throwable {
+        super.finalize();
+    }*/
+    
+    private void dispatchPointer(MotionEvent event) {
+        synchronized (mLock) {
+            String action;
+            switch (event.getActionMasked()) {
+                case MotionEvent.ACTION_DOWN:
+                    action = "down";
+                    break;
+                case MotionEvent.ACTION_UP:
+                    action = "up";
+                    break;
+                case MotionEvent.ACTION_MOVE:
+                    action = "move";
+                    break;
+                case MotionEvent.ACTION_CANCEL:
+                    action = "cancel";
+                    break;
+                case MotionEvent.ACTION_HOVER:
+                    action = "hover";
+                    break;
+                case MotionEvent.ACTION_ENTER_PROXIMITY:
+                    action = "enter proximity";
+                    break;
+                case MotionEvent.ACTION_EXIT_PROXIMITY:
+                    action = "exit proximity";
+                    break;
+                default:
+                    action = "none";
+                    break;
+            }
+            if (event.getSource() == InputDevice.SOURCE_ACTIVE_STYLUS) {
+                mX = event.getX();
+                mY = event.getY();
+
+                Slog.i(TAG, "Stylus: " + action + " - X: " + event.getX(0) + ", Y: " + event.getY(0) + 
+                        " Pressure: " + event.getPressure());
+
+                if (event.getActionMasked() == MotionEvent.ACTION_ENTER_PROXIMITY) {
+                    mPointerInRange = true;
+                } else if (event.getActionMasked() == MotionEvent.ACTION_EXIT_PROXIMITY) {
+                    mPointerInRange = false;
+                }
+                
+                int metaState = event.getMetaState();
+                boolean buttonStylus = (metaState & KeyEvent.META_BTN_STYLUS_ON) > 0;
+                boolean buttonStylus2 = (metaState & KeyEvent.META_BTN_STYLUS2_ON) > 0;
+
+                if ((mCurrentPkg == null) && (mButtonStylus != buttonStylus)) {
+                    // State of side button changed
+                    if (buttonStylus) {
+                        setPointerLocked(mDefaultPointerSidePressed);
+                    } else {
+                        setPointerLocked(mDefaultPointer);
+                    }
+
+                    mButtonStylus = buttonStylus;
+                }
+
+                if (mVisible && mPointerInRange) {
+                    if (mPointerSurface != null) {
+                        int x = (int)(mX - mPointer.getOffsetX());
+                        int y = (int)(mY - mPointer.getOffsetY());
+
+                        Surface.openTransaction();
+                        Slog.d(TAG, "Open transaction for the pointer surface");
+                        try {
+                            mPointerSurface.setPosition(x, y);
+                            mPointerSurface.setLayer(mWindowManager.getTopAnimLayer() + 1);
+                            mPointerSurface.show();
+                            Slog.d(TAG, "Set pointer surface position, layer, and show");
+                        } catch (RuntimeException e) {
+                            Slog.e(TAG, "Failure showing pointer surface", e);
+                        } catch (RemoteException e) {
+                            Slog.e(TAG, "Error getting top layer value from window manager", e);
+                        } finally {
+                            Surface.closeTransaction();
+                            Slog.d(TAG, "Close transaction for the pointer surface");
+                        }
+                    }
+                } else {
+                    Surface.openTransaction();
+                    Slog.d(TAG, "Open transaction for the pointer surface");
+                    try {
+                        mPointerSurface.hide();
+                    } catch (Exception e) {
+                        Slog.e(TAG, "Failure hiding pointer surface", e);
+                    } finally {
+                        Surface.closeTransaction();
+                        Slog.d(TAG, "Close transaction for the pointer surface");
+                    }
+                }
+            } else if (event.getSource() == InputDevice.SOURCE_MOUSE) {
+                Slog.i(TAG, "Mouse: " + action + " - X: " + event.getX(0) + ", Y: " + event.getY(0));
+            } else {
+                Slog.i(TAG, "Other: " + action + " - X: " + event.getX(0) + ", Y: " + event.getY(0));
+            }
+            if (event.getActionMasked() == MotionEvent.ACTION_HOVER) {
+            }
+        }
+    }
+}
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index 5469509..2567e6b 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -235,6 +235,7 @@ class ServerThread extends Thread {
         NotificationManagerService notification = null;
         WallpaperManagerService wallpaper = null;
         LocationManagerService location = null;
+        PointerManagerService pointer = null;
 
         if (factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
             try {
@@ -453,6 +454,14 @@ class ServerThread extends Thread {
                 Slog.e(TAG, "Failure starting DiskStats Service", e);
             }
 
+            try {
+                Slog.i(TAG, "PointerManager Service");
+                pointer = new PointerManagerService(context, wm);
+                ServiceManager.addService("pointer", pointer);
+            } catch (Throwable e) {
+                Slog.e(TAG, "Failure starting PointerManager Service", e);
+            }
+
         }
 
         // make sure the ADB_ENABLED setting value matches the secure property value
@@ -513,6 +522,7 @@ class ServerThread extends Thread {
         final InputMethodManagerService immF = imm;
         final RecognitionManagerService recognitionF = recognition;
         final LocationManagerService locationF = location;
+        final PointerManagerService pointerF = pointer;
 
         // We now tell the activity manager it is okay to run third party
         // code.  It will call back into us once it has gotten to the state
@@ -541,6 +551,7 @@ class ServerThread extends Thread {
                 if (immF != null) immF.systemReady();
                 if (locationF != null) locationF.systemReady();
                 if (throttleF != null) throttleF.systemReady();
+                if (pointerF != null) pointerF.systemReady();
             }
         });
 
diff --git a/services/java/com/android/server/WindowManagerService.java b/services/java/com/android/server/WindowManagerService.java
index 10cceac..50bb08f 100644
--- a/services/java/com/android/server/WindowManagerService.java
+++ b/services/java/com/android/server/WindowManagerService.java
@@ -4597,6 +4597,14 @@ public class WindowManagerService extends IWindowManager.Stub
         }
     }
 
+    public int getTopAnimLayer() {
+        int layer;
+        synchronized (mWindowMap) {
+            layer = mWindows.get(mWindows.size() - 1).mAnimLayer;
+        }
+        return layer;
+    }
+
     /**
      * Starts the view server on the specified port.
      *
diff --git a/services/jni/com_android_server_InputManager.cpp b/services/jni/com_android_server_InputManager.cpp
index 5b5cdb0..de55763 100644
--- a/services/jni/com_android_server_InputManager.cpp
+++ b/services/jni/com_android_server_InputManager.cpp
@@ -22,7 +22,7 @@
 #define DEBUG_INPUT_READER_POLICY 0
 
 // Log debug messages about InputDispatcherPolicy
-#define DEBUG_INPUT_DISPATCHER_POLICY 0
+#define DEBUG_INPUT_DISPATCHER_POLICY 1
 
 #include "JNIHelp.h"
 #include "jni.h"
-- 
1.7.0.4

